# ###############################################################
# # Title:        Evaluate-STIG
# # Version:      1.2410.1
# # Description:  Automates STIG checklist creation
# # Date:         11/15/2024
# ###############################################################

#requires -version 5.1

<#
    .Synopsis
        Automatically creates STIG checklists (CKL).
    .DESCRIPTION
        Automates the documentation of STIG compliance into STIG Viewer compatible checklist (.ckl) files.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1

        Runs Evaluate-STIG with default settings ("Unclassified" ScanType, "DEFAULT" Answer Key, and output to C:\Users\Public\Public Documents)
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -AnswerKey TestNetwork

        Runs Evaluate-STIG for a classified system and instructs it to use the user defined "TestNetwork" Answer Key.  Refer to documentation on answer keys.
    .EXAMPLE
        PS C:\> $Result = .\Evaluate-STIG.ps1

        Runs Evaluate-STIG for an unclassified asset using the DEFAULT answer key and returns the results into a variable named "Result".
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ScanType Classified -ComputerName Workstation1

        Executes Classified scan on remote computer Workstation1.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ComputerName Workstation1,Workstation2,C:\Computers.txt -AltCredential -ThrottleLimit 7

        Executes Unclassifed scan on multiple computer names and a list of computers using an alternate credential and limiting concurrent scans to 7.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -SelectSTIG MSEdge,Chrome,Win10

        Selects Microsoft Edge, Google Chrome, and Windows 10 (by shortname) to be scanned.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -ExcludeSTIG DotNET4,WinServer2019

        Excludes .NET 4 Framework and Windows Server 2019 from scan.  All other STIGs will be scanned if applicable.
    .EXAMPLE
        PS C:\> .\Evaluate-STIG.ps1 -CiscoConfig C:\ShowTechFiles -ThrottleLimit 5 -VulnTimeout 5

        Recursively looks for supported Cisco show tech files in C:\ShowTechFiles, concurrently scans a maximum of 5 files at a time, and a 5 minute timeout for each Group ID.
    .INPUTS
        -ScanType <"Unclassified"|"Classified">
        Use to instruct Evaluate-STIG the classification of the asset.  Valid ScanTypes are "Unclassified" and "Classified".  If not specified, default will be "Unclassified".

        -Marking <String>
        Use to optionally set Marking in CKL and on header/footer of files generated by Evaluate-STIG.  Example use is "CUI"/"Confidential"/"Secret"/"Top Secret" but accepts any marking string.

        -VulnTimeout <Int16>
        Maximum time in minutes to allow a singular Group ID check to run.

        -AnswerKey <String>
        Use to instruct Evaluate-STIG which Answer Key to use for determining if a comment from an answer file should be applied.  Answer Keys are per Group ID and user-defined within the answer file.  If not specified, default Answer Key will be "DEFAULT".  Refer to documentation for more information.

        -AFPath <string>
        Path to Answer Files.  If not specified, defaults to $PsScriptRoot\AnswerFiles.

        -Output <"Console"|"CKL"|"CKLB"|"CSV"|"XCCDF"|"CombinedCKL"|"CombinedCKLB"|"CombinedCSV"|"OQE"|"Summary"|"STIGManager"|"Splunk">
        Specify output type(s).  Use comma separation for multiple.  If not specified, output will be returned to console.

        -JSON
        Output Console Object in JSON Format using OutputPayload Options.  JSON Objects are based on Group ID.  Requires -Output Console.

        -OutputPayload <"Title"|"Version"|"ReleaseDate"|"Classification"|"HostName"|"Site"|"Instance"|"IP"|"MAC"|"FQDN"|"Role"|"GroupID"|"GroupTitle"|"RuleID"|"STIGID"|"Severity"|"SeverityOverride"|"Justification"|"LegacyIDs"|"RuleTitle"|"Discussion"|"CheckText"|"FixText"|"CCI"|"Status"|"FindingDetails"|"Comments|"ESVersion"|"StartTime">
        Specify which fields to output when outputing to CSV, JSON, or Splunk.  Order of fields will be retained from command line.  For multiple, separate with commas.  Default is all fields.  Requires -Output CSV|CombinedCSV|Splunk or -JSON.

        -OutputPath <String>
        Sets the directory path for Evaluate-STIG to save output to (excluding STIGManager and Splunk).  Requires -Output.  May be a local or UNC path.  If not specified, default path will be C:\Users\Public\Public Documents or \opt\.  If using -OutputPath with -ComputerName, ensure the host computer's account has write access to the path in -OutputPath.

        -PreviousToKeep <Int16>
        Number of previous scan results to retain.  Default is 1.  Requires -Output.

        -AllowDeprecated
        Enable scanning of STIGs that are no longer available on cyber.mil (deprecated).  By default, deprecated STIGs will not be scanned.

        -AllowSeverityOverride
        Enables the use of the Severity Override and Justification fields in checklists.

        -SelectSTIG <String>
        Specify which STIG(s) to scan.  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For deprecated STIGs, must call -AllowDeprecated first.  For multiple STIGs, separate with commas.  Cannot be specified with -ExcludeSTIG.

        -ExcludeSTIG <String>
        Specify which STIG(s) to exclude from the scan.  Use Tab or CTRL+SPACE to properly exclude STIG(s) by its short name.  For multiple STIGs, separate with commas.  Cannot be specified with -SelectSTIG.

        -ForceSTIG <String>
        Ignore detection of STIG applicability and forcefully run a scan of selected STIG(s).  Use Tab or CTRL+SPACE to properly select STIG(s) by its short name.  For multiple STIGs, separate with commas.  *WARNING* Evaluate-STIG results are not guaranteed with this option.  Use at own risk. *WARNING*

        -SelectVuln <String>
        Specify which Group ID(s) to scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ExcludeVuln <String>
        Specify which Group ID(s) to exclude from a scan (V-#####).  For multiple, separate with commas.  Can only be used with -SelectSTIG.

        -ComputerName <String>
        Execute scan on remote computer.  Supports multiple computers through comma separation. Can be a computer name, a file with a list of computers, or a combination.  By default, results will be copied back to source computer.  Requires admin rights on remote computer.

        -CiscoConfig <String>
        Execute a scan of Cisco show tech files.  May be a path to a single file, a folder, or combination using comma separation.

        -ThrottleLimit <Int16>
        Number of concurrent Evaluate-STIG jobs to run when using -ComputerName or -CiscoConfig.  Default is 10. Requires -ComputerName or -CiscoConfig input.

        -AltCredential
        Prompts for an alternate credential to use for remote scans.  If connection to the remote machine fails with the alternate credential, Evaluate-STIG will fallback to the launching user and attempt the connection - essentially allowing for two credentials to be used for remote scan (e.g. workstation/server credentials).  Requires -ComputerName input.  Windows only.

        -SMCollection <String>
        Use to instruct Evaluate-STIG which STIGManager Collection to upload results.  Requires -Output STIGManager.

        -SMPassphrase <String>
        Passphrase to decrpyt private key if encrypted .key is used for authentication to a STIGManager instance.  Requires -Output STIGManager.

        -SplunkHECName <String>
        Use to direct Evaluate-STIG which configured Splunk HTTP Event Collection (HEC) to upload results.  Requires -Output Splunk.

        -ApplyTattoo
        Applies Evaluate-STIG tattooing on system.  Mainly for providing a detection method to configuration management tools.

        -ListSupportedProducts
        Lists all products that Evaluate-STIG currently supports.

        -ListApplicableProducts
        Lists all Evaluate-STIG supported STIGs that are applicable to the asset.

        -Version
        Display Evaluate-STIG version and running path.

        -Update
        Downloads updates to Evaluate-STIG from the Evaluate-STIG repo on SPORK.

        -LocalSource
        Directs -Update to download updates to Evaluate-STIG from a local Evaluate-STIG directory.

        -Proxy <String>
        Configure proxy for use with -Update.
    .LINK
        Evaluate-STIG
        https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig
        https://intelshare.intelink.gov/sites/NAVSEA-RMF

        Windows Remote Management (WinRM)
        https://docs.microsoft.com/en-us/windows/win32/winrm

        CMTrace (for viewing EValuate-STIG.log)
        https://docs.microsoft/en-us/configmgr/core/support/cmtrace
    #>

[CmdletBinding(PositionalBinding = $false)]
Param (
    [Parameter(Mandatory = $false)]
    [String[]]$ComputerName,

    [Parameter(Mandatory = $false)]
    [String[]]$CiscoConfig,

    # TODO: Staging VMWare Content
    # TODO: Need to require -VCenterApplianceName for -VMName, but do NOT need the inverse.
    #[Parameter(Mandatory = $false)]
    #[String[]]$VCenterApplianceName,

    #[Parameter(Mandatory = $false)]
    #[String[]]$VMName,

    [Parameter(Mandatory = $false)]
    [ValidateSet("Unclassified", "Classified")]
    [String]$ScanType = "Unclassified",

    [Parameter(Mandatory = $false)]
    [String]$Marking,

    [Parameter(Mandatory = $false)]
    [Int16]$VulnTimeout = 15,

    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [String]$AFPath,

    [Parameter(Mandatory = $false)]
    [String]$AnswerKey = "DEFAULT",

    # Code for -Output Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assit in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            $ValidValues = @("Console", "CKL", "CKLB", "CSV", "XCCDF", "CombinedCKL", "CombinedCKLB", "CombinedCSV", "OQE", "Summary", "STIGManager", "Splunk")
            $ValidValues | Where-Object { $_ -like "$WordToComplete*" }
        })]
    [ValidateScript({
            $ValidValues = @("Console", "CKL", "CKLB", "CSV", "XCCDF", "CombinedCKL", "CombinedCKLB", "CombinedCSV", "OQE", "Summary", "STIGManager", "Splunk")
            ForEach ($Value in ($_ -split ",")) {
                If ($Value -notin $ValidValues) {
                    Throw "`r`n `r`n'$_' is not a valid Output.  Valid Output entries include $($ValidValues -join ", ")`r`n `r`n"
                }
            }
            $true
        })]
    [String[]]$Output = "Console",

    [Parameter(Mandatory = $false)]
    [Switch]$ApplyTattoo,

    [Parameter(Mandatory = $false)]
    [Switch]$ListApplicableProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$ListSupportedProducts,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowDeprecated,

    [Parameter(Mandatory = $false)]
    [Switch]$AllowSeverityOverride,

    [Parameter(Mandatory = $false)]
    [Switch]$Version,

    [Parameter(Mandatory = $false)]
    [Switch]$Update,

    # Code for -SelectSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                If ($CommandAst.Parent.PipeLineElements -match "-AllowDeprecated") {
                    $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }
                Else {
                    $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Where-Object DisaStatus -NE "Deprecated" | Select-Object Name, ShortName -Unique | Sort-Object ShortName
                }

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            $PrefsXML = Join-Path $PsScriptRoot -ChildPath "Preferences.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG | Where-Object DisaStatus -NE "Deprecated").ShortName
                $DeprecatedSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG | Where-Object DisaStatus -EQ "Deprecated").ShortName
                If (Test-Path $PrefsXML) {
                    Try {
                        $PrefAllowDep = ((Select-Xml -Path $PrefsXML -XPath "/" | Select-Object -ExpandProperty Node).Preferences.EvaluateSTIG.AllowDeprecated).Trim()
                    }
                    Catch {
                        Throw "`r`n `r`nPreferences.xml cannot be read.  Cannot continue.`r`n `r`n"
                    }
                }
                $_ -Split "," | ForEach-Object {
                    If (($_ -in $ValidSTIGs) -or ($_ -in $DeprecatedSTIGs -and ($PSBoundParameters.Keys -contains "AllowDeprecated" -or $PrefAllowDep -eq "true"))) {
                        $true
                    }
                    ElseIf ($DeprecatedSTIGs -contains $_) {
                        Throw "`r`n `r`n'$_' is a deprecated STIG.  Please use '-AllowDeprecated' to enable deprecated STIG scans.`r`n `r`n"
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$SelectSTIG,

    # Code for -ExcludeSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript( {
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG).ShortName
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ExcludeSTIG,

    # Code for -ForceSTIG Option
    # https://powershell.one/powershell-internals/attributes/autocompletion
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [ArgumentCompleter({
            # Recieve information about current state to assist in auto-completing user typed value
            Param($CommandName, $ParameterName, $WordToComplete, $CommandAst, $FakeBoundParameters)

            # Get STIG ShortNames from STIGList.xml
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $STIGs = ([XML](Get-Content $STIGListXML)).List.STIG | Select-Object Name, ShortName -Unique | Sort-Object ShortName

                # Compose CompletionResult Entries
                $STIGs | Where-Object {$_.Shortname} | Where-Object {$_.ShortName -like "$WordToComplete*"} | ForEach-Object {
                    $STIGSN = $_.Shortname
                    If ($STIGSN -like '* *') {
                        $STIGSN = "'$STIGSN'"
                    }
                    [Management.Automation.CompletionResult]::New($STIGSN, $STIGSN, "ParameterValue", $_.Name)
                }
            }
        })]
    [ValidateScript({
            $STIGListXML = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (Test-Path $STIGListXML) {
                $ValidSTIGs = (([XML](Get-Content $STIGListXML)).List.STIG).ShortName
                $_ -Split "," | ForEach-Object {
                    If ($_ -in $ValidSTIGs) {
                        $true
                    }
                    Else {
                        Throw "`r`n `r`n'$_' is not a product supported by Evaluate-STIG.  Please use CTRL+SPACE to list valid products.`r`n `r`n"
                    }
                }
            }
            Else {
                Throw "`r`n `r`n'$STIGListXML' does not exist.  Cannot continue.`r`n `r`n"
            }
        })]
    [Array]$ForceSTIG
)

# Expose additional dynamic parameters
DynamicParam {
    $ParamDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary

    If ($ComputerName -and (-Not($IsLinux)) -or $CiscoConfig -or $VCenterApplianceName -or $VMName) {
        If ($ComputerName -or ($VCenterApplianceName -or $VMName)) {
            # Expose -AltCredential if -ComputerName is specified
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $CredParam = New-Object System.Management.Automation.RuntimeDefinedParameter("AltCredential", [Switch], $AttributeCollection)
            $ParamDictionary.Add("AltCredential", $CredParam)
        }

        # Expose -ThrottleLimit
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ThrottleParam = New-Object System.Management.Automation.RuntimeDefinedParameter("ThrottleLimit", [Int16], $AttributeCollection)
        $ParamDictionary.Add("ThrottleLimit", $ThrottleParam)
    }

    If ($Update) {
        # Expose -Proxy
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ProxyParam = New-Object System.Management.Automation.RuntimeDefinedParameter("Proxy", [String], $AttributeCollection)
        $ParamDictionary.Add("Proxy", $ProxyParam)

        #Expose -LocalSource
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $LocalSourceParam = New-Object System.Management.Automation.RuntimeDefinedParameter("LocalSource", [String], $AttributeCollection)
        $ParamDictionary.Add("LocalSource", $LocalSourceParam)
    }

    If ($Output) {
        If (($Output -Split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
            # Expose -OutputPath
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $OutputPathParam = New-Object System.Management.Automation.RuntimeDefinedParameter("OutputPath", [String], $AttributeCollection)
            $ParamDictionary.Add("OutputPath", $OutputPathParam)

            # Expose -PreviousToKeep
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $PreviousToKeepParam = New-Object System.Management.Automation.RuntimeDefinedParameter("PreviousToKeep", [Int16], $AttributeCollection)
            $ParamDictionary.Add("PreviousToKeep", $PreviousToKeepParam)
        }

        If (($Output -Split ",").Trim() -match @("(^STIGManager$)")) {
            # Expose -SMPassphrase
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $SMPassphraseParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SMPassphrase", [String], $AttributeCollection)
            $ParamDictionary.Add("SMPassphrase", $SMPassphraseParam)

            # Expose -SMCollection
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $true
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $SMCollectionParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SMCollection", [String], $AttributeCollection)
            $ParamDictionary.Add("SMCollection", $SMCollectionParam)
        }

        If (($Output -Split ",").Trim() -match @("(^Splunk$)")) {
            # Expose -SplunkHECName
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $true
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $SplunkHECNameParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SplunkHECName", [String], $AttributeCollection)
            $ParamDictionary.Add("SplunkHECName", $SplunkHECNameParam)
        }

        If (($Output -Split ",").Trim() -match @("(^Console$)")) {
            # Expose -JSON
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $AttributeCollection.Add($Attributes)
            $JSONParam = New-Object System.Management.Automation.RuntimeDefinedParameter("JSON", [Switch], $AttributeCollection)
            $ParamDictionary.Add("JSON", $JSONParam)
        }

        If (($Output -Split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)") -or $ParamDictionary.Keys -contains "JSON") {
            # Expose -OutputPayload
            $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
            $Attributes = New-Object System.Management.Automation.ParameterAttribute
            $Attributes.Mandatory = $false
            # --- Begin ValidateSet parameter validation ---
            $value = @('Title', 'Version', 'ReleaseDate', 'Classification', 'HostName', 'Site', 'Instance', 'IP', 'MAC', 'FQDN', 'Role', 'GroupID', 'GroupTitle', 'RuleID', 'STIGID', 'Severity', 'SeverityOverride' , 'Justification', 'LegacyIDs', 'RuleTitle', 'Discussion', 'CheckText', 'FixText', 'CCI', 'Status', 'FindingDetails', 'Comments', 'ESVersion', 'StartTime')
            $v = New-Object System.Management.Automation.ValidateSetAttribute($value)
            $AttributeCollection.Add($v)
            # --- End ValidateSet parameter validation ---
            $AttributeCollection.Add($Attributes)
            $OutputPayloadParam = New-Object System.Management.Automation.RuntimeDefinedParameter("OutputPayload", [Array], $AttributeCollection)
            $ParamDictionary.Add("OutputPayload", $OutputPayloadParam)
        }
    }

    If ($SelectSTIG) {
        # Expose -SelectVuln
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $SelectVulnParam = New-Object System.Management.Automation.RuntimeDefinedParameter("SelectVuln", [Array], $AttributeCollection)
        $ParamDictionary.Add("SelectVuln", $SelectVulnParam)

        # Expose -ExcludeVuln
        $Attributes = New-Object System.Management.Automation.ParameterAttribute
        $Attributes.Mandatory = $false
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $AttributeCollection.Add($Attributes)
        $ExcludeVulnParam = New-Object System.Management.Automation.RuntimeDefinedParameter("ExcludeVuln", [Array], $AttributeCollection)
        $ParamDictionary.Add("ExcludeVuln", $ExcludeVulnParam)
    }

    Return $ParamDictionary
}

Process {
    Try {
        # Initialize ExitCode variable
        $ExitCode = 0

        # Just a blank line in console for readability
        Write-Host ""

        # -Update and external scripts reference the below $EvaluateStigVersion line as written.  Do not modify.
        $EvaluateStigVersion = "1.2410.1"

        # Collect dynamic / prepare array parameters
        If ($ComputerName) {
            $ComputerName = $ComputerName -Split ","
        }
        If ($CiscoConfig) {
            $CiscoConfig = $CiscoConfig -Split ","
        }
        If ($Output) {
            $Output = $Output -Split ","
        }
        If ($SelectSTIG) {
            $SelectSTIG = $SelectSTIG -Split ","
        }
        If ($ExcludeSTIG) {
            $ExcludeSTIG = $ExcludeSTIG -Split ","
        }
        If ($ForceSTIG) {
            $ForceSTIG = $ForceSTIG -Split ","
        }
        If ($PsBoundParameters.OutputPath) {
            $OutputPath = $PsBoundParameters.OutputPath
        }
        If ("PreviousToKeep" -in $PsBoundParameters.Keys) {
            $PreviousToKeep = $PsBoundParameters.PreviousToKeep
        }
        Else {
            $PreviousToKeep = 1
        }
        If ($PsBoundParameters.AltCredential) {
            $AltCredential = "{0}" -f $PsBoundParameters.AltCredential
        }
        If ($PsBoundParameters.SelectVuln) {
            $SelectVuln = ($PsBoundParameters.SelectVuln -Split ",").Trim() | Sort-Object -Unique
        }
        If ($PsBoundParameters.ExcludeVuln) {
            $ExcludeVuln = ($PsBoundParameters.ExcludeVuln -Split ",").Trim() | Sort-Object -Unique
        }
        If ($PsBoundParameters.OutputPayload) {
            $OutputPayload = $PsBoundParameters.OutputPayload
            [string]$ParamList = $OutputPayload
        }
        If ($PsBoundParameters.ThrottleLimit) {
            $ThrottleLimit = $PsBoundParameters.ThrottleLimit
        }
        If ($PSBoundParameters.SMPassphrase) {
            $SMPassphrase = $PsBoundParameters.SMPassphrase | ConvertTo-SecureString -AsPlainText -Force
        }
        If ($PSBoundParameters.SMCollection) {
            $SMCollection = $PsBoundParameters.SMCollection
        }
        If ($PSBoundParameters.SplunkHECName) {
            $SplunkHECName = $PsBoundParameters.SplunkHECName
        }
        If ($PSBoundParameters.JSON) {
            $JSON = $PsBoundParameters.JSON
        }

        # ---------- Begin Prechecks ----------
        # Get PowerShell version and OS platform (Linux or Windows).  If unsupported detected, fail out.
        $PowerShellVersion = $PsVersionTable.PSVersion
        If ($PowerShellVersion -ge [Version]"7.0") {
            If ($PowerShellVersion -ge [Version]"7.2") {
                $PSStyleBackup = @{
                    ProgressView    = $PSStyle.Progress.View
                    OutputRendering = $PSStyle.OutputRendering
                }
                $PSStyle.Progress.View = "Classic"
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::PlainText
            }
            If ($IsLinux -eq $true) {
                $Global:OSPlatform = "Linux"
            }
            If ($IsWindows -eq $true) {
                $Global:OSPlatform = "Windows"
                [Version]$WMFVersion = (PowerShell.exe -Command {$PsVersionTable}).PsVersion
                If ($WMFVersion -lt [Version]"5.1") {
                    $ExitCode = 1
                    Throw "Windows Management Framework (WMF) $($WMFVersion -join '.') detected.  WMF 5.1 or greater is required."
                }
            }
        }
        ElseIf ($PowerShellVersion -lt [Version]"5.1" -or ($PowerShellVersion -join ".") -like "6.*") {
            $ExitCode = 1
            Throw "PowerShell $($PowerShellVersion -join '.') detected.  Evaluate-STIG only supports PowerShell 5.1 or PowerShell 7.x and greater.  PowerShell 6.x is not supported."
        }
        Else {
            $Global:OSPlatform = "Windows"
        }

        # Import required modules
        If (Test-Path (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions")) {
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath "Master_Functions") -SkipEditionCheck -ErrorAction Stop
            }
        }
        Else {
            $ExitCode = 2
            Throw "'Master_Functions' module not found.  Unable to continue."
        }

        # If -ListApplicableProducts, -ListSupportedProducts, or -Version are specified and not the only param specified, error out.
        If (($PsBoundParameters.Keys | Measure-Object).Count -gt 1) {
            ForEach ($Key in $PsBoundParameters.Keys) {
                If ($Key -in @("ListApplicableProducts", "ListSupportedProducts", "Version")) {
                    $ExitCode = 1
                    Throw "-$Key must not have additional parameters specified."
                }
            }
        }

        # If both -ComputerName and -CiscoConfig are specified, error out.  Only one may be specified.
        If (($ComputerName) -and ($CiscoConfig -or $VCenterApplianceName)) {
            $ExitCode = 1
            Throw "-ComputerName and -CiscoConfig cannot both be specified."
            # TODO: Swap the below line IN once VCenter is supported
            #Throw "Cannot specify more than one these parameters at a time: -ComputerName, -CiscoConfig or $VCenterApplianceName."
        }

        # If both -SelectSTIG and -ExcludeSTIG are specified, error out.  Only one may be specified.
        If (($SelectSTIG) -and ($ExcludeSTIG)) {
            $ExitCode = 1
            Throw "-SelectSTIG and -ExcludeSTIG cannot both be specified."
        }

        # Confirm -SelectVuln/-ExcludeVuln are properly formatted
        If ($SelectVuln) {
            ForEach ($Item in $SelectVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    $ExitCode = 1
                    Throw "$Item is an invalid entry for -SelectVuln.  Must be V-####."
                }
            }
        }
        ElseIf ($ExcludeVuln) {
            ForEach ($Item in $ExcludeVuln) {
                If ($Item -notmatch "^V-\d{4,6}$") {
                    $ExitCode = 1
                    Throw "$Item is an invalid entry for -ExcludeVuln.  Must be V-####."
                }
            }
        }
        # ---------- Begin Prechecks ----------

        # ---------- Begin Utility Parameters ----------
        # If -ListSupportedSTIGs specified, display list and exit.
        If ($ListSupportedProducts) {
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                $ExitCode = 1
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of supported STIGs
            $Result = (Get-SupportedProducts -ES_Path $PsScriptRoot)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()

            Return $Result
        }

        # If -ListApplicableProducts specified, display list and exit.
        If ($ListApplicableProducts) {
            # Confirm we have an elevated session.
            Switch ($OSPlatform) {
                "Windows" {
                    If (-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -and !$AltCredential -and ($LinuxList.count -eq 0)) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }
                }
                "Linux" {
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session."
                    }
                }
            }

            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $XmlFile = Join-Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$Xmlfile' file not found.  Please update with -Update option."
            }
            ElseIf (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' file not found.  Please update with -Update option."
            }
            ElseIf ((Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd) -ne $true) {
                $ExitCode = 1
                Throw "'$Xmlfile' failed schema validation.  Please update with -Update option."
            }

            # Get list of applicable STIGs
            $Result = (Get-ApplicableProducts -ES_Path $PsScriptRoot)

            # Remove InstalledSoftware variable if it exists
            If ($null -ne $Global:InstalledSoftware) {
                Remove-Variable -Name InstalledSoftware -Scope Global
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()

            Return $Result
        }

        # If -Version specified, display its output.
        If ($Version) {
            $Result = [PSCustomObject]@{
                Version     = $EvaluateStigVersion
                RunningPath = $PSScriptRoot
            }
            Return $Result
        }

        # If -Update specified, download the latest updates.
        If ($Update) {
            Try {
                If ($PSBoundParameters.LocalSource) {
                    $LocalSource = $PSBoundParameters.LocalSource
                }

                If ($PSBoundParameters.Proxy) {
                    $Proxy = $PSBoundParameters.Proxy
                }

                Get-FileUpdatesFromRepo -PS_Path $PsScriptRoot -Proxy $Proxy -LocalSource $LocalSource

                If ($PSStyleBackup) {
                    # Restore $PSStyle settings
                    $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                    $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
                [System.GC]::Collect()

                Exit $ExitCode
            }
            Catch {
                $ExitCode = 1
                Throw $_
            }
        }
        # ---------- Begin Utility Parameters ----------

        # Read in Preferences.xml and set parameters if not called from command line
        $Preferences_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_Preferences.xsd"
        $Preferences_xml = Join-Path -Path $PsScriptRoot -ChildPath "Preferences.xml"
        If (Test-Path $Preferences_xml) {
            $ParameterList = (Get-Command -Name (Join-Path $PsScriptRoot -ChildPath ($MyInvocation.MyCommand))).Parameters

            # Validate Preferences.xml against schema
            If (-Not(Test-Path $Preferences_xsd)) {
                $ExitCode = 2
                Throw "'$Preferences_xsd' file not found.  Please update with -Update option."
            }
            Else {
                $Valid = Test-XmlValidation -XmlFile $Preferences_xml -SchemaFile $Preferences_xsd
                If ($Valid -ne $true) {
                    $Msg = "'$Preferences_xml' failed schema validation." | Out-String
                    $Msg += $Valid.Message | Out-String
                    $ExitCode = 1
                    Throw $Msg
                }
            }

            # Set parameters defined in Preferences.xml.  Parameters called from command line override Preferences.xml
            $Preferences = (Select-Xml -Path $Preferences_xml -XPath /).Node
            $InUsePrefs = New-Object System.Collections.Generic.List[System.Object]
            ForEach ($Item in ($Preferences.Preferences.EvaluateSTIG | Get-Member -MemberType Property | Where-Object Name -NE '#comment').Name) {
                If ($Preferences.Preferences.EvaluateSTIG.$Item -ne '' -and (-Not($Item -in $PSBoundParameters.Keys))) {
                    $InUsePrefs.Add($Item)
                    # Prerequisite param must be verified before setting dynamic param
                    Switch ($Item) {
                        "ExcludeVuln" {
                            $Prereq = @("SelectSTIG")
                            ForEach ($obj in $Prereq) {
                                # Dynamic parameters must be added to $PSBoundParameters
                                If ($PSBoundParameters.Keys -contains $obj) {
                                    $PSBoundParameters.Add($Item, $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", ''))
                                    Break
                                }
                            }
                        }
                        "JSON" {
                            Set-Variable -Name $Item -Value $([System.Convert]::ToBoolean($($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')))
                        }
                        DEFAULT {
                            # Static parameters must have their variable set
                            Try {
                                If ($ParameterList[$Item].ParameterType.Name -eq "SwitchParameter") {
                                    Set-Variable -Name $Item -Value $([System.Convert]::ToBoolean($($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')))
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "String[]") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                ElseIf ($ParameterList[$Item].ParameterType.Name -eq "Array") {
                                    Set-Variable -Name $Item -Value $([String[]]$Preferences.Preferences.EvaluateSTIG.$Item -Split ",")
                                }
                                Else {
                                    Set-Variable -Name $Item -Value $($Preferences.Preferences.EvaluateSTIG.$Item -replace '"', '' -replace "'", '')
                                }
                            }
                            Catch {
                                $Msg = "Invalid entry in Preferences.xml for '$Item'" | Out-String
                                If ((Get-Variable $Item).Attributes.ValidValues) {
                                    $Msg += "Valid values include $((Get-Variable $Item).Attributes.ValidValues -join ', ')" | Out-String
                                }
                                $Msg += $_.Exception.Message | Out-String
                                $ExitCode = 1
                                Throw $Msg
                            }
                        }
                    }
                }
            }

            If (($Output -Split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)") -or $JSON) {
                If (-Not("OutputPayload" -in $PSBoundParameters.Keys)) {
                    $InUsePayload = New-Object System.Collections.Generic.List[System.Object]
                    ForEach ($Item in ($Preferences.Preferences.OutputPayload.SelectNodes("*").LocalName)) {
                        Try {
                            if ($([System.Convert]::ToBoolean($($Preferences.Preferences.OutputPayload.$Item -replace '"', '' -replace "'", '')))) {
                                $InUsePayload.Add($Item)
                            }
                        }
                        Catch {
                            $Msg = "Invalid entry in Preferences.xml for '$Item' in <OutputPayload>" | Out-String
                            $Msg += "Valid values include 'true', 'false'" | Out-String
                            $Msg += $_.Exception.Message | Out-String
                            $ExitCode = 1
                            Throw $Msg
                        }
                    }
                    Set-Variable -Name "OutputPayload" -Value $([String[]]$InUsePayload -Split ",")
                }
            }
        }

        if (($Output -split ",").Trim() -match @("(^STIGManager$)")) {
            If ($PowerShellVersion -le [Version]"7.0") {
                $ExitCode = 1
                Throw "PowerShell $($PowerShellVersion -join '.') detected.  STIGManager integration requires PowerShell 7.x and greater."
            }

            ForEach ($Item in ($Preferences.Preferences.STIGManager | Get-Member -MemberType Property | Where-Object Definition -Match string | Where-Object Name -NE '#comment').Name) {
                $Preferences.Preferences.STIGManager.$Item = $Preferences.Preferences.STIGManager.$Item -replace '"', '' -replace "'", ''
            }

            #Validate STIGMan Preferences
            if (-Not($Preferences.Preferences.STIGManager.SMImport_API_BASE)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_API_BASE."
            }
            if (-Not($Preferences.Preferences.STIGManager.SMImport_AUTHORITY)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_AUTHORITY."
            }

            if ($Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection) {
                $STIGManagerObject = $Preferences.Preferences.STIGManager | Select-Object -ExpandProperty SMImport_COLLECTION | Where-Object Name -EQ $SMCollection

                ForEach ($Item in ($STIGManagerObject | Get-Member -MemberType Property | Where-Object Definition -Match string).Name) {
                    $STIGManagerObject.$Item = $STIGManagerObject.$Item -replace '"', '' -replace "'", ''
                }
            }
            else {
                $ExitCode = 1
                Throw "STIGManager: $SMCollection not found or parameter missing."
            }
            if (-Not($STIGManagerObject.SMImport_CLIENT_ID)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_CLIENT_ID."
            }
            if (-Not($STIGManagerObject.SMImport_COLLECTION_ID)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_COLLECTION_ID."
            }
            if (-Not(Test-Path $STIGManagerObject.SMImport_CLIENT_CERT)) {
                $ExitCode = 1
                Throw "STIGManager preferences missing SMImport_CLIENT_CERT or file not found."
            }
            If ($STIGManagerObject.SMImport_CLIENT_CERT_KEY) {
                if (Test-Path $STIGManagerObject.SMImport_CLIENT_CERT_KEY) {
                    if ($STIGManagerObject.SMImport_CLIENT_CERT_KEY -and (-Not($SMPassphrase))) {
                        $ExitCode = 1
                        Throw "STIGManager Key detected but no Passphrase was provided."
                    }
                }
                else {
                    $ExitCode = 2
                    Throw "STIGManager preferences missing SMImport_CLIENT_CERT_KEY or file not found."
                }
            }
        }

        if (($Output -split ",").Trim() -match @("(^Splunk$)")) {
            If ($PowerShellVersion -le [Version]"7.0") {
                $ExitCode = 1
                Throw "PowerShell $($PowerShellVersion -join '.') detected.  Splunk integration requires PowerShell 7.x and greater."
            }

            ForEach ($Item in ($Preferences.Preferences.Splunk | Get-Member -MemberType Property | Where-Object Definition -Match string | Where-Object Name -NE '#comment').Name) {
                $Preferences.Preferences.Splunk.$Item = $Preferences.Preferences.Splunk.$Item -replace '"', '' -replace "'", ''
            }

            #Validate Splunk Preferences
            if (-Not($Preferences.Preferences.Splunk.Splunk_URI)) {
                $ExitCode = 1
                Throw "Splunk preferences missing Splunk_URI."
            }
            if ($Preferences.Preferences.Splunk | Select-Object -ExpandProperty Splunk_HECName | Where-Object Name -EQ $SplunkHECName) {
                $SplunkObject = $Preferences.Preferences.Splunk | Select-Object -ExpandProperty Splunk_HECName | Where-Object Name -EQ $SplunkHECName

                ForEach ($Item in ($SplunkObject | Get-Member -MemberType Property | Where-Object Definition -Match string).Name) {
                    $SplunkObject.$Item = $SplunkObject.$Item -replace '"', '' -replace "'", ''
                }
            }
            else {
                $ExitCode = 1
                Throw "Splunk: $SplunkHECName not found or parameter missing."
            }
            if (-Not($SplunkObject.Splunk_token)) {
                $ExitCode = 1
                Throw "Splunk preferences missing Splunk_token."
            }
        }

        # Validate AFPath
        If ($AFPath) {
            If (-Not($AFPath | Test-Path)) {
                $ExitCode = 3
                Throw "-AFPath either does not exist or is not accessible."
            }
            ElseIf (($AFPath | Test-Path) -and (-Not($AFPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                $ExitCode = 1
                Throw "-AFPath must point to a directory."
            }
        }

        # Validate OutputPath
        If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
            Switch ($OSPlatform) {
                "Windows" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("$($env:PUBLIC)\Documents\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("/", "\")) -replace "\\$") -eq $DefaultOutputPath) {
                        $OutputPath = "$env:PUBLIC\Documents\STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            $null = New-Item -Path $(Split-Path -Path $OutputPath -Parent) -Name $(Split-Path -Path $OutputPath -Leaf) -ItemType Directory
                        }
                    }
                }
                "Linux" {
                    $DefaultOutputPath = [IO.Path]::GetFullPath("\opt\STIG_Compliance")
                    If ((-Not($OutputPath)) -or [IO.Path]::GetFullPath($(($OutputPath).Replace("\", "/")) -replace "/$") -eq $DefaultOutputPath) {
                        $OutputPath = "/opt/STIG_Compliance"
                        If (-Not(Test-Path $OutputPath)) {
                            sudo mkdir $OutputPath
                        }
                    }
                }
            }
            If (-Not($OutputPath | Test-Path)) {
                $ExitCode = 3
                Throw "-OutputPath either does not exist or is not accessible."
            }
            ElseIf (($OutputPath | Test-Path) -and (-Not($OutputPath | Test-Path -PathType 'Container' -ErrorAction SilentlyContinue))) {
                $ExitCode = 1
                Throw "-OutputPath must point to a directory."
            }

            $OutputPath = Convert-Path (Resolve-Path -Path $OutputPath -ErrorAction Stop).Path
        }

        # Set initial variables
        $Global:LogComponent = "Evaluate-STIG $($ESVersion)"
        $Global:ESVersion = $EvaluateStigVersion

        # If -AFPath not specified, set default
        If (-Not($AFPath)) {
            $AFPath = (Join-Path -Path $PsScriptRoot -ChildPath "AnswerFiles")
        }

        If ($host.privatedata) {
            Try {
                # Set Progress Bar Colors
                $host.privatedata.ProgressForegroundColor = "White"

                Switch ($ScanType) {
                    "Unclassified" {
                        $host.privatedata.ProgressBackgroundColor = "DarkGreen"
                    }
                    "Classified" {
                        $host.privatedata.ProgressBackgroundColor = "DarkRed"
                    }
                }
            }
            Catch {
                # Do nothing
            }
        }

        if ($Marking) {
            $Marking = $Marking.ToUpper()
        }

        If ($ComputerName) {
            #####################################################
            # Scan remote system
            #####################################################
            If ($IsLinux) {
                $ExitCode = 1
                Throw "Parameter -ComputerName is only supported on Windows systems."
            }

            # Set working dir for remote scans
            Switch ($OSPlatform) {
                "Windows" {
                    $RemoteScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $RemoteScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $RemoteWorkingDir = Join-Path -Path $RemoteScanDir -ChildPath "RemoteScanTemp"

            If (-Not(Test-Path $RemoteScanDir)) {
                $null = New-Item -Path $RemoteScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $RemoteWorkingDir)) {
                $null = New-Item -Path $RemoteWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Check/Create lock file
            If (Test-Path (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck)) {
                $ProcLockInfo = Get-Content (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                If ($ProcLockInfo) {
                    Try {
                        If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                            $ExitCode = 33
                            Throw "Evaluate-STIG is currently processing remote scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                        }
                    }
                    Catch {
                        Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                        Exit $ExitCode
                    }
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $RemoteWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # Get local host data
            $LocalHost = New-Object System.Collections.Generic.List[System.Object]
            $NewObj = [PSCustomObject]@{
                HostName    = ([Environment]::MachineName).ToUpper()
                IPv4Address = (Get-NetIPAddress).IPv4Address
            }
            $LocalHost.Add($NewObj)

            # If source machine is to be scanned, confirm PS is elevated or that -AltCredential is selected
            If (($ComputerName -contains "127.0.0.1") -or ($ComputerName -contains "::1") -or ($ComputerName -contains "localhost") -or ($ComputerName -match $LocalHost.HostName) -or ($LocalHost.IPv4Address | ForEach-Object {If ($_ -in $ComputerName) {
                            Return $true
                        }})) {
                If (-NOT(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -or $AltCredential)) {
                    $ExitCode = 5
                    Throw "LOCALHOST to be included in scan.  You must run this from an elevated PowerShell session or use -AltCredential."
                }
            }

            # Build arguments hashtable
            $HashArguments = @{
                ComputerName      = $ComputerName
                ScanType          = $ScanType
                VulnTimeout       = $VulnTimeout
                AFPath            = $AFPath
                AnswerKey         = $AnswerKey
                ESVersion         = $ESVersion
                LogComponent      = $LogComponent
                OSPlatform        = $OSPlatform
                ES_Path           = $PsScriptRoot
                RemoteScanDir     = $RemoteScanDir
                RemoteWorkingDir  = $RemoteWorkingDir
                PowerShellVersion = $PowerShellVersion
            }
            If ($Marking) {
                $HashArguments.Add("Marking", $Marking)
            }
            If ($Output) {
                $HashArguments.Add("Output", $($Output -join ","))

                If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                    $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                }

                If (($Output -split ",").Trim() -match @("(^STIGManager$)")) {
                    if ($SMPassphrase) {
                        $HashArguments.Add("SMPassphrase", $SMPassphrase)
                    }
                    if ($SMCollection) {
                        $HashArguments.Add("SMCollection", $SMCollection)
                    }
                }

                if (($Output -split ",").Trim() -match @("(^Splunk$)")) {
                    if ($SplunkHECName) {
                        $HashArguments.Add("SplunkHECName", $SplunkHECName)
                    }
                }

                If (($Output -Split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)")) {
                    $HashArguments.Add("OutputPayload", $OutputPayload)
                }
            }
            If ($OutputPath) {
                $HashArguments.Add("OutputPath", $OutputPath)
            }
            If ($ApplyTattoo) {
                $HashArguments.Add("ApplyTattoo", $true)
            }
            If ($AllowDeprecated) {
                $HashArguments.Add("AllowDeprecated", $true)
            }
            If ($AllowSeverityOverride) {
                $HashArguments.Add("AllowSeverityOverride", $true)
            }
            If ($SelectSTIG) {
                $HashArguments.Add("SelectSTIG", $SelectSTIG)
            }
            If ($SelectVuln) {
                $HashArguments.Add("SelectVuln", $SelectVuln)
            }
            If ($ExcludeSTIG) {
                $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
            }
            If ($ExcludeVuln) {
                $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
            }
            If ($ForceSTIG) {
                $HashArguments.Add("ForceSTIG", $ForceSTIG)
            }
            If ($AltCredential) {
                $HashArguments.Add("AltCredential", $true)
            }
            If ($ThrottleLimit) {
                $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
            }

            $ScanResult = Invoke-RemoteScan @HashArguments

            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        ElseIf ($CiscoConfig) {
            #####################################################
            # Scan Cisco Show Tech Files
            #####################################################
            # Set working dir for Cisco scans
            Switch ($OSPlatform) {
                "Windows" {
                    $CiscoScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $CiscoScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $CiscoWorkingDir = Join-Path -Path $CiscoScanDir -ChildPath "CiscoScanTemp"

            If (-Not(Test-Path $CiscoScanDir)) {
                $null = New-Item -Path $CiscoScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $CiscoWorkingDir)) {
                $null = New-Item -Path $CiscoWorkingDir -ItemType Directory -ErrorAction Stop
            }

            If (Test-Path $CiscoConfig -ErrorAction Stop) {
                # Test OutputPath connectivity
                If ($OutputPath -and -Not(Test-Path $OutputPath)) {
                    $ExitCode = 5
                    Throw "$OutputPath is not accessible by $([Environment]::Username) on $MachineName."
                }

                # Check/Create lock file
                If (Test-Path (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck)) {
                    $ProcLockInfo = Get-Content (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                    If ($ProcLockInfo) {
                        Try {
                            If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                                $ExitCode = 33
                                Throw "Evaluate-STIG is currently processing Cisco scans from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                            }
                        }
                        Catch {
                            Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                            Exit $ExitCode
                        }
                    }
                }
                $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
                Set-Content -Path (Join-Path $CiscoWorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

                # Build arguments hashtable
                $HashArguments = @{
                    CiscoConfig       = $CiscoConfig
                    ScanType          = $ScanType
                    VulnTimeout       = $VulnTimeout
                    AFPath            = $AFPath
                    AnswerKey         = $AnswerKey
                    ESVersion         = $ESVersion
                    LogComponent      = $LogComponent
                    OSPlatform        = $OSPlatform
                    ES_Path           = $PsScriptRoot
                    PowerShellVersion = $PowerShellVersion
                    CiscoScanDir      = $CiscoScanDir
                    CiscoWorkingDir   = $CiscoWorkingDir
                }
                If ($Marking) {
                    $HashArguments.Add("Marking", $Marking)
                }
                If ($Output) {
                    $HashArguments.Add("Output", $Output)

                    If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                        $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                    }

                    If ("STIGManager" -in $Output) {
                        if ($SMPassphrase) {
                            $HashArguments.Add("SMPassphrase", $SMPassphrase)
                        }
                        if ($SMCollection) {
                            $HashArguments.Add("SMCollection", $SMCollection)
                        }
                    }

                    if ("Splunk" -in $Output) {
                        if ($SplunkHECName) {
                            $HashArguments.Add("SplunkHECName", $SplunkHECName)
                        }
                    }

                    If (($Output -split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)")) {
                        $HashArguments.Add("OutputPayload", $OutputPayload)
                    }
                }
                If ($OutputPath) {
                    $HashArguments.Add("OutputPath", $OutputPath)
                }
                If ($AllowDeprecated) {
                    $HashArguments.Add("AllowDeprecated", $true)
                }
                If ($AllowSeverityOverride) {
                    $HashArguments.Add("AllowSeverityOverride", $true)
                }
                If ($SelectSTIG) {
                    $HashArguments.Add("SelectSTIG", $SelectSTIG)
                }
                If ($SelectVuln) {
                    $HashArguments.Add("SelectVuln", $SelectVuln)
                }
                If ($ExcludeSTIG) {
                    $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
                }
                If ($ExcludeVuln) {
                    $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                }
                If ($ForceSTIG) {
                    $HashArguments.Add("ForceSTIG", $ForceSTIG)
                }
                If ($ThrottleLimit) {
                    $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
                }

                $ScanResult = Invoke-ConfigFileScan @HashArguments
            }
            Else {
                $ExitCode = 3
                Throw "Cannot find path '$CiscoConfig' because it does not exist."
            }
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        ElseIf ($VCenterApplianceName -or $VMName) {
            # TODO: THIS IS PRE-STAGING. NOT IN USE AT THIS TIME.
            #####################################################
            # Scan VCenter Appliance or VM
            #####################################################
            # TODO: Confirm if PowerCLI works w/ 5.2 AND 7.X. If ONLY 5.2 is useable remove any references to Linux.
            # both 5.2 and 7.X seem to support PowerCLI. Need to test PowerCLI + Linux
            # https://www.vgemba.net/vmware/PowerShell-PowerCLI-Part-1/
            # PowerCLI seems to support Linux
            # https://developer.vmware.com/docs/17472/-compatibility-matrix
            # TODO: Test if a process lock is required.

            # Set working dir for VCenter Scans
            Switch ($OSPlatform) {
                "Windows" {
                    $VCenterScanDir = Join-Path -Path (Get-Item $env:TEMP).FullName -ChildPath "Evaluate-STIG"
                }
                "Linux" {
                    $VCenterScanDir = "/tmp/Evaluate-STIG"
                }
            }
            $VCenterWorkingDir = Join-Path -Path $VCenterScanDir -ChildPath "VCenterScanTemp"

            If (-Not(Test-Path $VCenterScanDir)) {
                $null = New-Item -Path $VCenterScanDir -ItemType Directory -ErrorAction Stop
            }
            If (-Not(Test-Path $VCenterWorkingDir)) {
                $null = New-Item -Path $VCenterWorkingDir -ItemType Directory -ErrorAction Stop
            }

            # Ensure required modules are available
            If (-Not((Get-Module -ListAvailable -Name "VMWare.PowerCLI"))) {
                # TODO: Error out unable to process because module is missing.
                $ExitCode = 1
                Throw "'VMWare.PowerCLI' module is NOT available to PowerShell. VMWare checklists will NOT be generated."
            }
            Remove-Variable -Name 'AvailableModules'

            # Import required modules
            If ($PowerShellVersion -lt [Version]"7.0") {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                    Join-Path -ChildPath "VMWare_Functions") -ErrorAction Stop
            }
            Else {
                Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" |
                    Join-Path -ChildPath "VMWare_Functions") -SkipEditionCheck -ErrorAction Stop
            }

            # Build arguments hashtable
            $HashArguments = @{
                # Standard Arguments
                ScanType             = $ScanType
                VulnTimeout          = $VulnTimeout
                AFPath               = $AFPath
                AnswerKey            = $AnswerKey
                PreviousToKeep       = $PreviousToKeep
                ESVersion            = $ESVersion
                LogComponent         = $LogComponent
                OSPlatform           = $OSPlatform
                ES_Path              = $PsScriptRoot
                PowerShellVersion    = $PowerShellVersion
                # Custom Arugments
                VCenterApplianceName = $($VCenterApplianceName)
                VCenterScanDir       = $($VCenterScanDir)
                VCenterWorkingDir    = $($VCenterWorkingDir)
            }
            # Standard Arguments
            If ($Marking) {
                $HashArguments.Add("Marking", $Marking)
            }
            If ($Output) {
                $HashArguments.Add("Output", $Output)

                If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                    $HashArguments.Add("PreviousToKeep", $PreviousToKeep)
                }

                If (($Output -split ",").Trim() -match @("(^STIGManager$)")) {
                    if ($SMPassphrase) {
                        $HashArguments.Add("SMPassphrase", $SMPassphrase)
                    }
                    if ($SMCollection) {
                        $HashArguments.Add("SMCollection", $SMCollection)
                    }
                }

                if (($Output -split ",").Trim() -match @("(^Splunk$)")) {
                    if ($SplunkHECName) {
                        $HashArguments.Add("SplunkHECName", $SplunkHECName)
                    }
                }

                If (($Output -split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)")) {
                    $HashArguments.Add("OutputPayload", $OutputPayload)
                }
            }
            If ($OutputPath) {
                $HashArguments.Add("OutputPath", $OutputPath)
            }
            If ($AllowDeprecated) {
                $HashArguments.Add("AllowDeprecated", $true)
            }
            If ($AllowSeverityOverride) {
                $HashArguments.Add("AllowSeverityOverride", $true)
            }
            If ($SelectSTIG) {
                $HashArguments.Add("SelectSTIG", $SelectSTIG)
            }
            If ($SelectVuln) {
                $HashArguments.Add("SelectVuln", $SelectVuln)
            }
            If ($ExcludeSTIG) {
                $HashArguments.Add("ExcludeSTIG", $ExcludeSTIG)
            }
            If ($ExcludeVuln) {
                $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
            }
            If ($ForceSTIG) {
                $HashArguments.Add("ForceSTIG", $ForceSTIG)
            }
            If ($ThrottleLimit) {
                $HashArguments.Add("ThrottleLimit", $ThrottleLimit)
            }
            # Custom Arguments
            If ($VMName) {
                $HashArguments.Add('VMName', $VMName)
            }

            # TODO: Add lock if it is going in here.

            # TODO: Uncomment this line when ready.
            #$ScanOutput = Invoke-VCenterQuery @HashArguments

            If (Test-Path $VCenterWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $VCenterWorkingDir\Evaluate-STIG.lck -Force
            }
        }
        Else {
            #####################################################
            # Scan local system
            #####################################################
            $Global:ScanStartDate = (Get-Date -Format "MM/dd/yyyy")

            # OS dependent prerequiste checks
            Switch ($OSPlatform) {
                "Windows" {
                    # Confirm we have an elevated session.
                    If (-NOT([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator") -and !$AltCredential -and ($LinuxList.count -eq 0)) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session or use -AltCredential."
                    }

                    # Check Windows version.  Windows version 6.1 or greater required.
                    # https://docs.microsoft.com/en-us/windows/win32/sysinfo/operating-system-version
                    If ([Version](Get-CimInstance Win32_OperatingSystem).Version -lt "6.1") {
                        $ExitCode = 1
                        Throw "$((Get-CimInstance Win32_OperatingSystem).Version) is not supported.  Must be version 6.1 or greater.  Cannot continue."
                    }

                    # Confirm native PowerShell session
                    $OSArch = (Get-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name PROCESSOR_ARCHITECTURE).PROCESSOR_ARCHITECTURE
                    If ($OSArch -eq "AMD64") {
                        If ([IntPtr]::Size -ne "8") {
                            $ExitCode = 1
                            Throw "32-Bit PowerShell session detected.  Evaluate-STIG must be ran in 64-Bit PowerShell on 64-Bit systems."
                        }
                    }
                }
                "Linux" {
                    # Confirm we have an elevated session.
                    If ((id -u) -ne 0) {
                        $ExitCode = 5
                        Throw "You must run this from an elevated PowerShell session."
                    }

                    # Check for prerequisites
                    $null = lshw -version 2>/dev/null

                    if ($ComputerName) {
                        $ExitCode = 1
                        Throw "Remote computer option supports Windows only."
                    }
                }
            }

            # Test OutputPath connectivity
            If ($OutputPath -and -Not(Test-Path $OutputPath)) {
                $ExitCode = 5
                Throw "$OutputPath is not accessible by $([Environment]::Username) on $MachineName."
            }

            # Set variables
            Switch ($OSPlatform) {
                "Windows" {
                    $Global:WorkingDir = "$env:windir\Temp\Evaluate-STIG"
                    $DomainRole = (Get-DomainRoleStatus).RoleFriendlyName
                    $HiveFile = "$($WorkingDir)\Eval-STIG_UserHive.dat" # Copy of user's registry hive
                    $ES_Hive_Tasks = @("Eval-STIG_SaveHive", "Eval-STIG_LoadHive", "Eval-STIG_UnloadHive") # Potential scheduled tasks for user hive actions
                }
                "Linux" {
                    $Global:WorkingDir = "/tmp/Evaluate-STIG"
                    $Release = Get-Content /etc/os-release
                    If ($release | Select-String "Workstation") {
                        $DomainRole = "Member Workstation"
                    }
                    ElseIf ($release | Select-String "Server") {
                        $DomainRole = "Member Server"
                    }
                    Else {
                        $DomainRole = "Member Workstation"
                    }
                }
            }
            $MachineName = ([Environment]::MachineName).ToUpper()
            If ($OutputPath) {
                If ($SelectVuln) {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath "_Partial_$MachineName"
                }
                Else {
                    $Global:ResultsPath = Join-Path -Path $OutputPath -ChildPath $MachineName
                }
            }
            $StartTime = Get-Date
            $Date = Get-Date -Format yyyyMMdd
            $Global:STIGLog = Join-Path -Path $WorkingDir -ChildPath "Evaluate-STIG.log"
            [int]$Global:TotalMainSteps = 1
            [int]$Global:CurrentMainStep = 1
            [int]$Global:ProgressId = 1
            if ($Marking) {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Marking: $Marking | Answer Key: $AnswerKey)"
            }
            else {
                $Global:ProgressActivity = "Evaluate-STIG (Version: $ESVersion | Scan Type: $ScanType | Answer Key: $AnswerKey)"
            }

            # Create WorkingDir
            If (-Not(Test-Path $WorkingDir)) {
                $null = New-Item $WorkingDir -ItemType Directory
            }

            # Check/Create lock file
            If (Test-Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck)) {
                $ProcLockInfo = Get-Content (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -ErrorAction Stop
                If ($ProcLockInfo) {
                    Try {
                        If (Get-Process -Name $ProcLockInfo.split("`r`n")[0] | Where-Object { $_.Id -eq $ProcLockInfo.split("`r`n")[1] }) {
                            $ExitCode = 33
                            Throw "Evaluate-STIG is currently processing from another source or was terminated unexpectedly.`r`nProcess Name : $($ProcLockInfo.split("`r`n")[0])`r`nProcess ID   : $($ProcLockInfo.split("`r`n")[1])"
                        }
                    }
                    Catch {
                        Write-Host $_.Exception.Message -ForegroundColor Red -BackgroundColor Black
                        Exit $ExitCode
                    }
                }
            }
            $CurrentProcess = [System.Diagnostics.Process]::GetCurrentProcess()
            Set-Content -Path (Join-Path $WorkingDir -ChildPath Evaluate-STIG.lck) -Value "$($CurrentProcess.ProcessName)`n$($CurrentProcess.ID)"

            # ++++++++++++++++++++++ Begin processing ++++++++++++++++++++++
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Initializing and generating list of required STIGs"

            If (Test-Path $STIGLog) {
                Remove-Item $STIGLog -Force
            }

            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "Begin Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Reconstruct command line for logging purposes
            $CommandLine = Get-CommandLine -CommandName "Evaluate-STIG.ps1" -BoundParameters $PSBoundParameters

            Write-Log -Path $STIGLog -Message "Executing: $($CommandLine)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $InUsePrefs | ForEach-Object {
                Write-Log -Path $STIGLog -Message "Utilizing Preference: $($_) $($Preferences.Preferences.EvaluateSTIG.$_)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            If (($Output -split ",").Trim() -match @("(^CSV$|^CombinedCSV$|^Splunk$)") -or $JSON) {
                Write-Log -Path $STIGLog -Message "Utilizing Output Payload: $($OutputPayload -join ",")" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Verify Evaluate-STIG files integrity
            Write-Log -Path $STIGLog -Message "Verifying Evaluate-STIG file integrity" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If (Test-Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")) {
                [XML]$FileListXML = Get-Content -Path (Join-Path -Path $PSScriptRoot -ChildPath "xml" | Join-Path -ChildPath "FileList.xml")
                $FileListValid = Test-XmlSignature -checkxml $FileListXML -Force
                Switch ($FileListValid) {
                    $true {
                        $Verified = $true
                        $XccdfFailedHash = @()
                        ForEach ($File in $FileListXML.FileList.File) {
                            $Path = (Join-Path -Path $PsScriptRoot -ChildPath $File.Path | Join-Path -ChildPath $File.Name)
                            If (Test-Path $Path) {
                                If ((Get-FileHash -Path $Path -Algorithm SHA256).Hash -ne $File.SHA256Hash) {
                                    $Verified = $false
                                    If ($File.Name -like "*xccdf.xml") {
                                        $XccdfFailedHash += $File.Name
                                    }
                                    Write-Log -Path $STIGLog -Message "WARNING: '$($Path)' failed integrity check." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                }
                            }
                            Else {
                                If ($File.ScanReq -eq "Required") {
                                    $Verified = $false
                                    Write-Log -Path $STIGLog -Message "ERROR: '$($File.Name)' is a required file but not found.  Scan results may be incomplete." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                }
                            }
                        }
                        If ($Verified -eq $true) {
                            Write-Log -Path $STIGLog -Message "Evaluate-STIG file integrity check passed." -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "WARNING: One or more Evaluate-STIG files failed integrity check." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                    $false {
                        Write-Log -Path $STIGLog -Message "ERROR: 'FileList.xml' failed authenticity check.  Unable to verify content integrity." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    DEFAULT {
                        Write-Log -Path $STIGLog -Message "ERROR: Test-XmlSignature on 'FileList.xml' failed with the following message:" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message $FileListValid -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                }
            }
            Else {
                $ExitCode = 2
                Throw "'FileList.xml' not found."
            }

            # Schema Files
            $STIGList_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_STIGList.xsd"
            $AnswerFile_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "Schema_AnswerFile.xsd"
            $Checklist_xsd = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "U_Checklist_Schema_V2.xsd"
            $Checklist_json = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "CKLB.schema.json"
            If (-Not(Test-Path $STIGList_xsd)) {
                $ExitCode = 2
                Throw "'$STIGList_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $AnswerFile_xsd)) {
                $ExitCode = 2
                Throw "'$AnswerFile_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_xsd)) {
                $ExitCode = 2
                Throw "'$Checklist_xsd' - file not found."
            }
            ElseIf (-Not(Test-Path $Checklist_json)) {
                $ExitCode = 2
                Throw "'$Checklist_json' - file not found."
            }

            # STIGList.xml validation
            $XmlFile = Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml"
            If (-Not(Test-Path $XmlFile)) {
                $ExitCode = 2
                Throw "'$XmlFile' - file not found."
            }
            Else {
                $Result = Test-XmlValidation -XmlFile $XmlFile -SchemaFile $STIGList_xsd
                If ($Result -ne $true) {
                    ForEach ($Item in $Result.Message) {
                        Write-Log -Path $STIGLog -Message $Item -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    $ExitCode = 1
                    Throw "'$($XmlFile)' failed XML validation"
                }
            }

            Write-Log -Path $STIGLog -Message "Evaluate-STIG Version: $ESVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Launching User: $([Environment]::Username)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Pre-checks passed.  Begin processing.
            # =====================================
            # Write configuration data to log
            Write-Log -Path $STIGLog -Message "Hostname: $MachineName" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Domain Role: $DomainRole" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "OS Platform: $OSPlatform" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "PS Version: $PowerShellVersion" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Scan Type: $ScanType" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer Key: $AnswerKey" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Answer File Path: $AFPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Results Path: $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # --- Begin Answer File validation
            Write-Log -Path $STIGLog -Message "Validating answer files" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            $AnswerFileList = New-Object System.Collections.Generic.List[System.Object]
            $XmlFiles = Get-ChildItem -Path $AFPath | Where-Object Extension -EQ ".xml"

            # Verify answer files for proper format
            ForEach ($Item in $XmlFiles) {
                $Validation = (Test-XmlValidation -XmlFile $Item.FullName -SchemaFile $AnswerFile_xsd)
                If ($Validation -eq $true) {
                    Write-Log -Path $STIGLog -Message "$($Item.Name) : Passed" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    [XML]$Content = Get-Content $Item.FullName
                    If ($Content.STIGComments.Name) {
                        $NewObj = [PSCustomObject]@{
                            STIG          = $Content.STIGComments.Name
                            Name          = $Item.Name
                            FullName      = $Item.FullName
                            LastWriteTime = $Item.LastWriteTime
                        }
                        $AnswerFileList.Add($NewObj)
                    }
                }
                Else {
                    Write-Log -Path $STIGLog -Message "ERROR: $($Item.Name) : Answer file failed schema validation and will be ignored.  Please correct or remove." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "$($Validation.Message)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            $AnswerFileList = $AnswerFileList | Sort-Object LastWriteTime -Descending
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            # --- End Answer File validation

            # Build list of required STIGs
            Write-Log -Path $STIGLog -Message "Gathering list of STIGs applicable to this sytem" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            [XML]$STIGList = Get-Content (Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath "STIGList.xml")
            $STIGsToProcess = New-Object System.Collections.Generic.List[System.Object]
            If ($SelectSTIG) {
                ForEach ($Node in ($STIGList.List.STIG | Where-Object {$OSPlatform -in ($_.ApplicableOS -split ",").Trim() -and $_.AssetType -eq "Other"})) {
                    If ($Node.StigContent -in $XccdfFailedHash) {
                        Write-Log -Path $STIGLog -Message "ERROR: $($Node.StigContent) : Failed hash check. This STIG will not be scanned." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    ElseIf ($Node.Shortname -in $SelectSTIG) {
                        If ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -eq $true) {
                            If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                }
                                Else {
                                    $AFtoUse = ""
                                }

                                # Determine deprecation
                                $Deprecated = $false
                                If ($Node.DisaStatus -eq "Deprecated") {
                                    $Deprecated = $true
                                }

                                $NewObj = [PSCustomObject]@{
                                    Name           = $Node.Name
                                    Shortname      = $Node.ShortName
                                    StigContent    = $Node.StigContent
                                    AnswerFile     = $AFtoUse
                                    PsModule       = $Node.PsModule
                                    PsModuleVer    = $Node.PsModuleVer
                                    UserSettings   = $Node.UserSettings
                                    CanCombine     = $Node.CanCombine
                                    Classification = $Node.Classification
                                    Deprecated     = $Deprecated
                                    Forced         = $false
                                }
                                $STIGsToProcess.Add($NewObj)
                            }
                        }
                        ElseIf ($Node.Shortname -notin $ForceSTIG) {
                            Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' requested with -SelectSTIG but is not applicable to this system so will be ignored." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                }
            }
            Else {
                ForEach ($Node in ($STIGList.List.STIG | Where-Object {$OSPlatform -in ($_.ApplicableOS -split ",").Trim() -and $_.AssetType -eq "Other"})) {
                    If ($Node.DisaStatus -eq "Deprecated" -and -Not($AllowDeprecated)) {
                        # Ignore deprecated STIG
                    }
                    Else {
                        If ($Node.StigContent -in $XccdfFailedHash) {
                            Write-Log -Path $STIGLog -Message "ERROR: $($Node.StigContent) : Failed hash check. This STIG will not be scanned." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                        ElseIf ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -eq $true) {
                            If ($Node.Shortname -in $ExcludeSTIG -and $Node.Shortname -notin $ForceSTIG) {
                                Write-Log -Path $STIGLog -Message "WARNING: '$($Node.Name)' is applicable to this system but has been excluded from scan with the -ExcludeSTIG option." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                    If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                        $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                    }
                                    Else {
                                        $AFtoUse = ""
                                    }

                                    # Determine deprecation
                                    $Deprecated = $false
                                    If ($Node.DisaStatus -eq "Deprecated") {
                                        $Deprecated = $true
                                    }

                                    $NewObj = [PSCustomObject]@{
                                        Name           = $Node.Name
                                        Shortname      = $Node.ShortName
                                        StigContent    = $Node.StigContent
                                        AnswerFile     = $AFtoUse
                                        PsModule       = $Node.PsModule
                                        PsModuleVer    = $Node.PsModuleVer
                                        UserSettings   = $Node.UserSettings
                                        CanCombine     = $Node.CanCombine
                                        Classification = $Node.Classification
                                        Deprecated     = $Deprecated
                                        Forced         = $false
                                    }
                                    $STIGsToProcess.Add($NewObj)
                                }
                            }
                        }
                    }
                }
            }

            # Add any forced STIGs to scan
            If ($ForceSTIG) {
                ForEach ($STIG in $ForceSTIG) {
                    If ($STIG -notin $STIGsToProcess.ShortName) {
                        $Node = $STIGList.List.STIG | Where-Object ShortName -EQ $STIG
                        If ($Node.StigContent -in $XccdfFailedHash) {
                            # Do nothing. We've already warned on bad file hash.
                        }
                        ElseIf (($STIGList.List.STIG | Where-Object ShortName -EQ $STIG).AssetType -notin @('Other')) {
                            Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' requested with -ForceSTIG but cannot be performed in this context. Ignoring." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                        Else {
                            If ($Node.DetectionCode -and (Invoke-Expression $Node.DetectionCode) -ne $true) {
                                $Forced = $true
                                Write-Log -Path $STIGLog -Message "WARNING: Scan for '$($Node.Name)' forced with -ForceSTIG.  Evaluate-STIG results are not guaranteed with this option.  Use at own risk." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            }
                            Else {
                                $Forced = $false
                            }
                            If ((Test-STIGDependencyFiles -RootPath $PSScriptRoot -STIGData $Node -LogPath $STIGLog -OSPlatform $OSPlatform) -eq $true) {
                                If ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)}) {
                                    $AFtoUse = ($AnswerFileList | Where-Object {($_.STIG -eq $Node.ShortName -or $_.STIG -eq $Node.Name)})[0]
                                }
                                Else {
                                    $AFtoUse = ""
                                }

                                # Determine deprecation
                                $Deprecated = $false
                                If ($Node.DisaStatus -eq "Deprecated") {
                                    $Deprecated = $true
                                }

                                $NewObj = [PSCustomObject]@{
                                    Name           = $Node.Name
                                    Shortname      = $Node.ShortName
                                    StigContent    = $Node.StigContent
                                    AnswerFile     = $AFtoUse
                                    PsModule       = $Node.PsModule
                                    PsModuleVer    = $Node.PsModuleVer
                                    UserSettings   = $Node.UserSettings
                                    CanCombine     = $Node.CanCombine
                                    Classification = $Node.Classification
                                    Deprecated     = $Deprecated
                                    Forced         = $Forced
                                }
                                $STIGsToProcess.Add($NewObj)
                            }
                        }
                    }
                }
            }
            [int]$TotalMainSteps = $TotalMainSteps + ($STIGsToProcess | Measure-Object).Count

            # Write list of STIGs that will be evaluated to log
            Write-Log -Path $STIGLog -Message "The following STIGs will be evaluated:" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            ForEach ($STIG in $STIGsToProcess | Sort-Object Name) {
                $AnswerFileMsg = ""
                If ($STIG.AnswerFile) {
                    $AnswerFileMsg = "  |  AnswerFile: $($STIG.AnswerFile.Name) (Modified: $(Get-Date (Get-ChildItem $STIG.AnswerFile.FullName).LastWriteTime -Format "dd MMM yyyy HH:mm:ss"))"
                }

                If ($STIG.Deprecated -eq $true) {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name) [Deprecated]$($AnswerFileMsg)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                }
                Else {
                    Write-Log -Path $STIGLog -Message "STIG: $($STIG.Name)$($AnswerFileMsg)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                }
            }
            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            # Confirm STIG specific prerequisites are met
            If (($STIGsToProcess.Name -like "Microsoft SQL Server*") -or ($STIGsToProcess.Name -like "IIS *")) {
                # IIS
                If ($STIGsToProcess.Name -like "IIS *") {
                    If (-Not(Get-Module -ListAvailable -Name "WebAdministration")) {
                        Write-Log -Path $STIGLog -Message "ERROR: 'WebAdministration' module is not available to PowerShell. IIS checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        $STIGsToIgnore = $STIGsToProcess | Where-Object Name -Like "IIS *"
                        ForEach ($Obj in $STIGsToIgnore) {
                            If ($Obj -in $STIGsToProcess) {
                                [Void]$STIGsToProcess.Remove($Obj)
                            }
                        }
                    }
                }

                # SQL Server
                If ($STIGsToProcess.Name -like "Microsoft SQL Server*") {
                    If (Get-Command Invoke-Sqlcmd -ErrorAction SilentlyContinue) {
                        $SQLCommand = (Get-Command Invoke-Sqlcmd)
                        Write-Log -Path $STIGLog -Message "Using Module: $($SQLCommand.Source) ($($SQLCommand.Version))" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Else {
                        Try {
                            $ImportedModules = Get-Module
                            $SQLModules = Get-Module -ListAvailable -Name "SqlServer", "SQLPS"
                            If (-Not($SQLModules)) {
                                Throw "ERROR: Neither 'SQLPS' nor 'SqlServer' modules is are available to PowerShell.  At least one must be installed.  SQL checklists will not be generated."
                            }
                            ElseIf ("SqlServer" -in $SQLModules.Name) {
                                If (-Not($ImportedModules | Where-Object Name -EQ "SqlServer")) {
                                    Try {
                                        Write-Log -Path $STIGLog -Message "Importing module: SqlServer" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                        (Get-Module -ListAvailable | Where-Object Name -EQ "SqlServer" | Sort-Object Version -Descending)[0] | Import-Module -WarningAction SilentlyContinue -ErrorAction Stop
                                    }
                                    Catch {
                                        Write-Log -Path $STIGLog -Message "ERROR: Failed to import 'SqlServer' module. SQL checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        If (Get-Module | Where-Object Name -EQ "SqlServer") {
                                            Remove-Module SqlServer -ErrorAction SilentlyContinue
                                        }
                                        Throw $_
                                    }
                                }
                                Else {
                                    $SQLModule = $ImportedModules | Where-Object Name -EQ "SqlServer"
                                    Write-Log -Path $STIGLog -Message "Module: $($SQLModule.Name) ($($SQLModule.Version)) already imported" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                }
                            }
                            Else {
                                If (-Not($ImportedModules | Where-Object Name -EQ "SQLPS")) {
                                    Try {
                                        Write-Log -Path $STIGLog -Message "Importing module: SQLPS" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                        (Get-Module -ListAvailable | Where-Object Name -EQ "SQLPS" | Sort-Object Version -Descending)[0] | Import-Module -WarningAction SilentlyContinue -ErrorAction Stop
                                    }
                                    Catch {
                                        Write-Log -Path $STIGLog -Message "ERROR: Failed to import 'SQLPS' module. SQL checklists will not be generated." -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        If (Get-Module | Where-Object Name -EQ "SQLPS") {
                                            Remove-Module SQLPS -ErrorAction SilentlyContinue
                                        }
                                        Throw $_
                                    }
                                }
                                Else {
                                    $SQLModule = $ImportedModules | Where-Object Name -EQ "SQLPS"
                                    Write-Log -Path $STIGLog -Message "Module: $($SQLModule.Name) ($($SQLModule.Version)) already imported" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                }
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message $_.Exception.Message -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            $STIGsToIgnore = $STIGsToProcess | Where-Object Name -Like "Microsoft SQL Server*"
                            ForEach ($Obj in $STIGsToIgnore) {
                                [Void]$STIGsToProcess.Remove($Obj)
                            }
                        }
                    }
                }
            }

            # If no supported STIGs are applicable, log it and continue
            If (($STIGsToProcess | Measure-Object).Count -eq 0) {
                Write-Log -Path $STIGLog -Message "WARNING: No Evaluate-STIG supported STIGs are applicable to this system." -WriteOutToStream -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform

                # Clean up
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent
                Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

                # Complete progress bar
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

                If ($PSStyleBackup) {
                    # Restore $PSStyle settings
                    $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                    $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
                }

                # Remove Evaluate-STIG modules from memory
                Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
                [System.GC]::Collect()

                # Exit with code
                Exit $ExitCode
            }
            Else {
                Write-Log -Path $STIGLog -Message "STIGs to process - $(($STIGsToProcess | Measure-Object).count)" -WriteOutToStream -FGColor Magenta -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }

            # Test connectivity to OutputPath and create folder for computer
            Try {
                If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                    If (-Not(Test-Path $ResultsPath)) {
                        $null = New-Item $ResultsPath -ItemType Directory -ErrorAction Stop
                        Start-Sleep 5
                    }
                }
            }
            Catch {
                Write-Log -Path $STIGLog -Message "ERROR: Failed to create output path '$($ResultsPath)'" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                $ExitCode = 1
                Throw $_
            }

            # Remove orphaned objects
            Write-Log -Path $STIGLog -Message "Checking for and removing orphaned objects from a previous scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Switch ($OSPlatform) {
                "Windows" {
                    # Remove existing Evaluate-STIG_UserHive in case it exists
                    If (Test-Path Registry::HKU\Evaluate-STIG_UserHive) {
                        [System.GC]::Collect()
                        Try {
                            Start-Sleep -Seconds 5
                            Write-Log -Path $STIGLog -Message "Removing orphaned object: HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            # REG command failed so attempt to do as SYSTEM
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to unload hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            Try {
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[2] -FilePath REG -ArgumentList "UNLOAD HKU\Evaluate-STIG_UserHive" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw # and exit
                                }
                            }
                            Catch {
                                $ExitCode = 1
                                Throw "Failed to unload user hive."
                            }
                        }
                    }

                    # Remove orphaned scheduled tasks
                    If (Get-Command -Name Get-ScheduledTask -ErrorAction SilentlyContinue) {
                        $Tasks = (Get-ScheduledTask | Where-Object TaskName -In $ES_Hive_Tasks).TaskName
                        If ($Tasks) {
                            ForEach ($Item in $Tasks) {
                                Unregister-ScheduledTask -TaskName $Item -Confirm:$false -ErrorAction Stop
                            }
                        }
                    }
                    Else {
                        ForEach ($Item in $ES_Hive_Tasks) {
                            $Task = ((SCHTASKS /Query /TN $Item /V /FO List 2>$null))
                            If ($Task) {
                                $null = SCHTASKS /Delete /TN $Item /F
                            }
                        }
                    }
                }
                "Linux" {
                    # TBD
                }
            }

            $TempFiles = Get-Item -Path $WorkingDir\* -Exclude Evaluate-STIG.log, Evaluate-STIG.lck -Force
            If ($TempFiles) {
                ForEach ($Item in $TempFiles) {
                    Write-Log -Path $STIGLog -Message "Removed orphaned object: $($Item.FullName)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $null = Remove-Item -Path $Item.FullName -Recurse -Force -ErrorAction Stop
                }
            }

            # Increase TotalMainSteps based on options/STIGs
            If (($Output -split ",").Trim() -match @("(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)")) {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match @("(^STIGManager$)")) {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match @("(^Splunk$)")) {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match @("(^Summary$)")) {
                $TotalMainSteps++
            }

            If (($Output -split ",").Trim() -match @("(^OQE$)")) {
                $TotalMainSteps++
            }

            If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                $TotalMainSteps++
            }

            # OS dependent steps
            If ($OSPlatform -eq "Windows") {
                $ExtFilesRequired = $false
                ForEach ($Item in $STIGsToProcess.ShortName) {
                    # Add STIG ShortNames that need an external file for processing (SecPol.ini, AppLocker.ini, Evaluate-STIG_FilesToScan.txt, etc)
                    If ($Item -in @("DotNET4", "IIS10Server", "IIS85Server", "Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "WinServerDNS", "JBoss")) {
                        $ExtFilesRequired = $true
                    }
                }
                If ($ExtFilesRequired -eq $true) {
                    $TotalMainSteps++
                }

                # =========== Determine User to Evaluate ===========
                If ($STIGsToProcess | Where-Object UserSettings -EQ $true) {
                    Write-Log -Path $STIGLog -Message "Determining which user to evaluate for HKCU items" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Determining user to evaluate and importing registry hive" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # Get all profile paths and find which ntuser.pol was most recently updated.
                    $UserToProcess = Get-UsersToEval -ProvideSingleUser
                    If ($UserToProcess) {
                        Write-Log -Path $STIGLog -Message "Will evaluate $($UserToProcess.Username) for user-based settings" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    ProfileType: $($UserToProcess.ProfileType)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($UserToProcess.LastPolicyUpdate -eq "Never") {
                            Write-Log -Path $STIGLog -Message "    LastPolicyUpdate: $($UserToProcess.LastPolicyUpdate)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "    LastPolicyUpdate: $($UserToProcess.LastPolicyUpdate) ($((New-TimeSpan -Start $UserToProcess.LastPolicyUpdate -End (Get-Date)).Days) days ago)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Write-Log -Path $STIGLog -Message "    SID: $($UserToProcess.SID)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    LocalPath: $($UserToProcess.LocalPath)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    ProfileLoadTime: $($UserToProcess.ProfileLoadTime)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    NTUserDatPath: $($UserToProcess.NTUserDatPath)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Write-Log -Path $STIGLog -Message "    NTUserDatUpdate: $($UserToProcess.NTUserDatUpdate)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($UserToProcess.Preferred) {
                            Write-Log -Path $STIGLog -Message "    Preferred: $($UserToProcess.Preferred)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        }
                        Else {
                            Write-Log -Path $STIGLog -Message "    Preferred: $($UserToProcess.Preferred)" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        }
                    }
                    Else {
                        Write-Log -Path $STIGLog -Message "WARNING: No scannable user profile found.  Will evaluate .DEFAULT profile for user-based settings" -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        $UserToProcess = @{ }
                        $UserToProcess.UserName = ".DEFAULT"
                        $UserToProcess.SID = ".DEFAULT"
                    }

                    # =========== Export and Load User Registry Hive ===========
                    If (Test-Path -Path Registry::HKU\$($UserToProcess.SID)) {
                        # User hive is currently loaded so we must save the loaded hive as we cannot copy NTUSER.DAT due to in use.
                        Try {
                            Write-Log -Path $STIGLog -Message "User's hive is currently loaded into the registry.  Saving HKU:\$($UserToProcess.SID) to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $Result = Start-Process -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -Wait -PassThru -WindowStyle Hidden
                            If ($Result.ExitCode -ne 0) {
                                Throw # and attempt as SYSTEM
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "WARNING: Failed to save hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                            # REG command failed so attempt to do as SYSTEM
                            Try {
                                If (Test-Path $HiveFile) {
                                    Remove-Item $HiveFile -Force
                                }
                                $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[0] -FilePath REG -ArgumentList "SAVE HKU\$($UserToProcess.SID) $($HiveFile) /y /c" -MaxRunInMinutes 1
                                If ($Result.LastTaskResult -ne 0) {
                                    Throw # and exit
                                }
                            }
                            Catch {
                                $ExitCode = 1
                                Throw "Failed to save user hive."
                            }
                        }
                    }
                    Else {
                        # User hive is not currently so we we will make a copy the user's NTUSER.DAT for importing
                        Write-Log -Path $STIGLog -Message "User's hive not found in registry.  Copying $($UserToProcess.NTUserDatPath) to $($HiveFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Copy-Item "$($UserToProcess.NTUserDatPath)" -Destination $HiveFile -Force -ErrorAction Stop
                    }

                    # Load the copied/saved user hive into HKU for parsing
                    Try {
                        Write-Log -Path $STIGLog -Message "Loading $($HiveFile) into HKU:\Evaluate-STIG_UserHive" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $Result = Start-Process -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -Wait -PassThru -WindowStyle Hidden
                        If ($Result.ExitCode -ne 0) {
                            Throw # and attempt as SYSTEM
                        }
                    }
                    Catch {
                        Write-Log -Path $STIGLog -Message "WARNING: Failed to load hive.  Trying as SYSTEM." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                        # REG command failed so attempt to do as SYSTEM
                        Try {
                            $Result = Invoke-TaskAsSYSTEM -TaskName $ES_Hive_Tasks[1] -FilePath REG -ArgumentList "LOAD HKU\Evaluate-STIG_UserHive $($HiveFile)" -MaxRunInMinutes 1
                            If ($Result.LastTaskResult -ne 0) {
                                Throw # and exit
                            }
                        }
                        Catch {
                            $ExitCode = 1
                            Throw "Failed to load user hive."
                        }
                    }
                }
                Else {
                    # Set UserName and SID to "NA"
                    $UserToProcess = @{
                        UserName = "NA"
                        SID      = "NA"
                    }
                }

                # =========== Create External Reference Files ===========
                If ($ExtFilesRequired -eq $true) {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Creating temporary export files for enumeration" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    $CurrentMainStep++

                    # AppLocker
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022")) {
                            $AppLockerRequired = $true
                        }
                    }
                    If ($AppLockerRequired -eq $true) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy and saving to $($WorkingDir)\$($AppLockerPolFile)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                            If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                Import-Module AppLocker
                            }
                            Else {
                                Import-Module AppLocker -SkipEditionCheck
                            }
                            Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $WorkingDir\$($AppLockerPolFile) -Force
                        }
                        Catch {
                            $AppLockerRequired = $false
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }

                    # Security Policy
                    ForEach ($Item in $STIGsToProcess.ShortName) {
                        If ($Item -in @("Win7", "Win10", "Win11", "WinServer2008R2MS", "WinServer2008R2DC", "WinServer2012DC", "WinServer2012MS", "WinServer2016", "WinServer2019", "WinServer2022", "WinServerDNS", "JBoss")) {
                            $SecPolRequired = $true
                        }
                    }
                    If ($SecPolRequired -eq $true) {
                        Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $SecPolFileName = "Evaluate-STIG_SecPol.ini"
                        Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($WorkingDir)\$($SecPolFileName)" -Wait -WindowStyle Hidden
                    }

                    # List of files to be scanned based on STIGs to evaluate
                    $FileExtensionsForScan = @()
                    $FilesToScan = @()
                    ForEach ($Item in $STIGsToProcess) {
                        Switch -Regex ($Item.ShortName) {
                            "^DotNET4$" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.exe.config
                                    $FileExtensionsForScan += "*.exe.config"

                                    # And machine.config files
                                    $FilesToScan += "$env:SYSTEMROOT\Microsoft.NET\Framework\v4.0.30319\Config\machine.config"
                                    If ((Get-CimInstance Win32_OperatingSystem).OSArchitecture -eq "64-bit") {
                                        $FilesToScan += "$env:SYSTEMROOT\Microsoft.NET\Framework64\v4.0.30319\Config\machine.config"
                                    }
                                }
                            }
                            "(^Win\d+$|^WinServer\d+\w*$)" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.p12 and *.pfx
                                    $FileExtensionsForScan += "*.p12"
                                    $FileExtensionsForScan += "*.pfx"
                                }
                            }
                            "^IIS\d+Server$" {
                                $FileSearchReq = $true

                                If ($SelectVuln -or $ExcludeVuln) {
                                    $HashArguments = @{
                                        ModulePath = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule))
                                    }
                                    If ($SelectVuln) {
                                        $HashArguments.Add("SelectVuln", $SelectVuln)
                                    }
                                    If ($ExcludeVuln) {
                                        $HashArguments.Add("ExcludeVuln", $ExcludeVuln)
                                    }

                                    $FileSearchReq = Test-IsFileSearchRequired @HashArguments
                                }

                                If ($FileSearchReq) {
                                    # STIG requires *.java and *.jpp
                                    $FileExtensionsForScan += "*.java"
                                    $FileExtensionsForScan += "*.jpp"
                                }
                            }
                        }
                    }
                    If ($FileExtensionsForScan) {
                        Try {
                            Write-Log -Path $STIGLog -Message "Collecting list of $($FileExtensionsForScan -join '|') files  to $($WorkingDir)\Evaluate-STIG_FilesToScan.txt" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            Write-Progress -Id ($ProgressId + 1) -Activity " " -Status "Collecting list of $($FileExtensionsForScan -join '|') files..."

                            # Get hard disk drive letters
                            $WMIDisks = (Get-CimInstance Win32_LogicalDisk | Where-Object DriveType -EQ 3).DeviceID
                            $Drives = (Get-PSDrive -PSProvider FileSystem | Where-Object {$_.DisplayRoot -eq $null -and $_.Root.TrimEnd('\') -in $WMIDisks}).Root

                            ForEach ($Drive in $Drives) {
                                $FilesToScan += Search-Files -Path $Drive -File $FileExtensionsForScan -ExcludePath @("$env:windir\CSC", "$env:windir\WinSxS", "$env:windir\servicing")
                            }
                            $FilesToScan | Where-Object {$_ -ne ""} | Out-File $WorkingDir\Evaluate-STIG_FilesToScan.txt -Force
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                }
            }
            Else {
                # Set UserName and SID to "NA"
                $UserToProcess = @{
                    UserName = whoami
                    SID      = "NA"
                }
            }

            # =========== Run the scans ===========
            If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                # $tmpResultsPath is needed for all filetype Outputs
                $tmpResultsPath = $(Join-Path -Path $WorkingDir -ChildPath "Results")
                If (-Not(Test-Path $tmpResultsPath)) {
                    $null = New-Item -Path $tmpResultsPath -ItemType Directory
                }
            }

            $ScanObjects = [System.Collections.Generic.List[System.Object]]::new()
            $ScanJobs = [System.Collections.Generic.List[System.Object]]::new()
            # Build list of jobs to be ran
            $STIGsToProcess = $STIGsToProcess | Sort-Object Name
            ForEach ($Item in $STIGsToProcess) {
                Try {
                    # Create subjobs object for STIGs that may apply multiple times (IIS, SQL, etc.)
                    $SubJobs = [System.Collections.Generic.List[System.Object]]::new()

                    # Temporarily import scan module for access to custom functions
                    If ($PowerShellVersion -lt [Version]"7.0") {
                        Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -ErrorAction Stop
                    }
                    Else {
                        Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Item.PsModule)) -SkipEditionCheck -ErrorAction Stop
                    }

                    # Set path to STIG .xccdf.xml and get needed data from it
                    $StigXmlPath = $(Join-Path -Path $PsScriptRoot -ChildPath "StigContent" | Join-Path -ChildPath $Item.StigContent)
                    $STIGID = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.ID).Trim()
                    $STIGTitle = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Title).Trim()
                    $STIGVer = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Version).Trim()
                    $STIGRel = ((((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Benchmark')[0].Trim() -split ' ')[1].Trim()
                    $STIGDate = (((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.'plain-text' | Where-Object { $_.id -eq "release-info" }).'#text' -split 'Date:')[1].Trim()
                    $STIGVersion = "V$($STIGVer)R$($STIGRel)"
                    $STIGStyleSheet = ((Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).'xml-stylesheet').Trim()
                    # Set STIG Classification
                    Switch -Regex ($STIGStyleSheet) {
                        'STIG_unclass.xsl' {
                            $Classification = "UNCLASSIFIED"
                        }
                        'STIG_cui.xsl' {
                            $Classification = "CUI"
                        }
                        DEFAULT {
                            $Classification = "No match in 'xml-stylesheet'."
                        }
                    }

                    $STIGTargetKey = (Select-Xml -Path $StigXmlPath -XPath "/" | Select-Object -ExpandProperty Node).Benchmark.Group[0].Rule.reference.identifier

                    # Build STIGInfo Object
                    $STIGInfo = [ordered]@{
                        STIGID         = $STIGID
                        Title          = $STIGTitle
                        Version        = $STIGVer
                        Release        = $STIGRel
                        ReleaseDate    = $STIGDate
                        Classification = $Classification
                    }

                    # Build TargetData Object
                    $TargetData = Get-AssetData -OSPlatform $OSPlatform -Marking $Marking
                    $TargetData.Add("TargetKey", $STIGTargetKey)
                    $TargetData.Add("WebOrDatabase", $false) # Initialize 'WebOrDatabase'.  If required, set below.
                    $TargetData.Add("Site", "")              # Initialize 'Site'.  If required, set below.
                    $TargetData.Add("Instance", "")          # Initialize 'Instance'.  If required, set below.

                    $STIGData = @{
                        StigXmlPath = $StigXmlPath
                        StigVersion = $STIGVersion
                        Name        = $Item.Name
                        ShortName   = $Item.ShortName
                        PsModule    = $Item.PsModule
                        CanCombine  = $Item.CanCombine
                    }

                    If ($Item.ShortName -like "IIS*") {
                        Remove-Module WebAdministration -ErrorAction SilentlyContinue
                        Import-Module WebAdministration -WarningAction SilentlyContinue
                    }

                    # Set parameters for Invoke-STIGScan
                    $ScanArgs = @{
                        StigXmlPath           = $StigXmlPath
                        VulnTimeout           = $($VulnTimeout)
                        SelectVuln            = $SelectVuln
                        ExcludeVuln           = $ExcludeVuln
                        Deprecated            = $Item.Deprecated
                        AllowSeverityOverride = $AllowSeverityOverride
                        Forced                = $Item.Forced
                        ModulesPath           = $(Join-Path -Path $PsScriptRoot -ChildPath "Modules")
                        PsModule              = $Item.PsModule
                        LogPath               = $STIGLog
                        OSPlatform            = $OSPlatform
                        ProgressId            = $ProgressId
                        ModuleArgs            = @{} # Initialze ModuleArgs object
                    }

                    # Set common arguments for scan module.  Additional variables and parameters may be added.
                    $ScanArgs.ModuleArgs.Add("ScanType", $ScanType)
                    if ($Item.AnswerFile.FullName) {
                        $ScanArgs.ModuleArgs.Add("AnswerFile", "'$($Item.AnswerFile.FullName)'")
                    }
                    else {
                        $ScanArgs.ModuleArgs.Add("AnswerFile", "")
                    }
                    $ScanArgs.ModuleArgs.Add("AnswerKey", $AnswerKey)
                    $ScanArgs.ModuleArgs.Add("Username", $UserToProcess.Username)
                    $ScanArgs.ModuleArgs.Add("UserSID", $UserToProcess.SID)
                    $ScanArgs.ModuleArgs.Add("ESVersion", $ESVersion)
                    $ScanArgs.ModuleArgs.Add("LogPath", $STIGLog)
                    $ScanArgs.ModuleArgs.Add("OSPlatform", $OSPlatform)
                    $ScanArgs.ModuleArgs.Add("LogComponent", $LogComponent)

                    # Determine additional arguments execute scan
                    Switch ($Item.ShortName) {
                        {$_ -in @("Apache24SiteUnix", "Apache24SiteWin")} {
                            # Get all the instances of apache running and their relevant information.
                            $ApacheInstances = @(Get-ApacheInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                            $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                            $ScanArgs.ModuleArgs.Add("SiteName", "")

                            ForEach ($instance in $ApacheInstances) {
                                $ScanArgs.ModuleArgs.ApacheInstance = $instance
                                ForEach ($vhost in $instance.VirtualHosts) {
                                    $ScanArgs.ModuleArgs.VirtualHost = $vhost
                                    If ($vhost.Index -eq -1) {
                                        $ScanArgs.ModuleArgs.SiteName = ("BaseConfig-" + $instance.Index)
                                    }
                                    Else {
                                        $ScanArgs.ModuleArgs.SiteName = ($vhost.SiteName + "-" + $vhost.SitePort)
                                    }

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.SiteName -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                                    $TargetData.Instance = ""

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                        }
                        {$_ -in @("Apache24SvrUnix", "Apache24SvrWin")} {
                            # Get all the instances of apache running and their relevant information.
                            $ApacheInstances = @(Get-ApacheInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("ApacheInstance", $null)
                            $ScanArgs.ModuleArgs.Add("VirtualHost", $null)
                            $ScanArgs.ModuleArgs.Add("SiteName", "")

                            ForEach ($instance in $ApacheInstances) {
                                $ScanArgs.ModuleArgs.ApacheInstance = $instance
                                $ScanArgs.ModuleArgs.SiteName = ("Server-" + $instance.Index)

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.SiteName -STIGVersion $STIGData.StigVersion

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $ScanArgs.ModuleArgs.SiteName
                                $TargetData.Instance = ""

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        "ArcGIS" {
                            [System.Collections.ArrayList]$ArcGISInstances = @(Get-ArcGISInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("ArcGISInstance", $null)
                            $ScanArgs.ModuleArgs.Add("Instance", "")

                            ForEach ($instance in $ArcGISInstances) {
                                $XmlObject = Get-XMLObject -Path $instance.ApplicationHost
                                if ($null -ne $XmlObject) {
                                    $SiteNames = Get-ArcGISSites -XmlObject $XmlObject
                                    if (($SiteNames | Measure-Object).Count -eq 1) {
                                        $SiteName = $SiteNames.name
                                    }
                                    else {
                                        $SiteName = ($SiteNames[0]).name
                                    }

                                    $FileSiteName = $SiteName -replace " ", "_"
                                }
                                else {
                                    $SiteName = $("Server-" + $instance.Index)
                                }
                                $ScanArgs.ModuleArgs.ArcGISInstance = $instance
                                $ScanArgs.ModuleArgs.Instance = ($SiteName)

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -HostName $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $FileSiteName -STIGVersion $STIGData.StigVersion

                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                                $TargetData.Instance = ""

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        "MSOffice365" {
                            # Set output filename
                            $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("InstalledO365Apps", $(Get-InstalledO365Apps))

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                        {$_ -in @("IIS10Site", "IIS85Site")} {
                            If (($PsVersionTable.PSVersion -join ".") -lt [Version]"6.0") {
                                Import-Module WebAdministration
                                $AllSites = Get-WebSite
                            }
                            Else {
                                $PSCommand = "PowerShell.exe -Command {Import-Module WebAdministration; Get-WebSite}"
                                $AllSites = Invoke-Expression $PSCommand
                            }

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("SiteName", "")

                            ForEach ($Site in $Allsites) {
                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Site.Name -STIGVersion $STIGData.StigVersion

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $Site.Name
                                $TargetData.Instance = ""

                                # Set SiteName in module arguments
                                $ScanArgs.ModuleArgs.SiteName = "'$($Site.Name)'"

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        "JBoss" {
                            [System.Collections.ArrayList]$JBossInstances = @(Get-JBossInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("JBossInstance", $null)
                            $ScanArgs.ModuleArgs.Add("Instance", "")

                            ForEach ($instance in $JBossInstances) {
                                $ScanArgs.ModuleArgs.JBossInstance = $instance
                                $ScanArgs.ModuleArgs.Instance = $instance.Server

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -STIGVersion $STIGData.StigVersion

                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = ""
                                $TargetData.Instance = $($Instance.Name)

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        "TrellixENS10xLocal" {
                            # Set output filename
                            $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("EnsConfig", $(Get-EnsConfig))

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                        "ApacheTomcatAS" {
                            [System.Collections.ArrayList]$TomcatInstances = @(Get-TomcatInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("TomcatInstance", $null)
                            $ScanArgs.ModuleArgs.Add("Instance", "")

                            ForEach ($instance in $TomcatInstances) {
                                $ScanArgs.ModuleArgs.TomcatInstance = $instance
                                $ScanArgs.ModuleArgs.Instance = "$($instance.Bindings)"

                                if (($instance.Bindings | Measure-Object).Count -eq 1) {
                                    $InstanceFileName = $instance.Bindings
                                }
                                else {
                                    $InstanceFileName = $instance.Bindings[0]
                                }
                                $InstanceFileName = $InstanceFileName -replace ':', '-'

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $InstanceFileName -STIGVersion $STIGData.StigVersion

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $($ScanArgs.ModuleArgs.Instance)
                                $TargetData.Instance = ""

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        {$_ -in @("SQL2014Instance", "SQL2016Instance")} {
                            Switch ($_) {
                                "SQL2014Instance" {
                                    $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}
                                }
                                "SQL2016Instance" {
                                    $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -ge "13.0"}
                                }
                            }

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("Instance", "")
                            $ScanArgs.ModuleArgs.Add("Database", "")

                            ForEach ($Instance in $allInstances) {
                                If ($Instance.Status -eq "Running") {
                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Instance.Name -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = ""
                                    $TargetData.Instance = $($Instance.Name)

                                    # Set Instance and Database in module arguments
                                    $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                    $ScanArgs.ModuleArgs.Database = "master"

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                            }
                        }
                        {$_ -in @("SQL2014DB", "SQL2016DB")} {
                            Switch ($_) {
                                "SQL2014DB" {
                                    $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -like "12.*"}
                                }
                                "SQL2016DB" {
                                    $allInstances = Get-AllInstances | Where-Object {[Version]$_.Version -ge "13.0"}
                                }
                            }

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("Instance", "")
                            $ScanArgs.ModuleArgs.Add("Database", "")
                            ForEach ($Instance in $allInstances) {
                                If ($Instance.Status -eq "Running") {
                                    $allDatabases = (Get-ISQL -ServerInstance $Instance.Name -qry "select name from sys.databases where state = 0").Name
                                    ForEach ($Database in $allDatabases) {
                                        # Set output filename
                                        $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $Instance.Name -Database $Database -STIGVersion $STIGData.StigVersion

                                        # Update TargetData
                                        $TargetData.WebOrDatabase = $true
                                        $TargetData.Site = $Database
                                        $TargetData.Instance = $($Instance.Name)

                                        # Set Instance and Database in module arguments
                                        $ScanArgs.ModuleArgs.Instance = "'$($Instance.Name)'"
                                        $ScanArgs.ModuleArgs.Database = "'$($Database)'"

                                        # Build and add sub job
                                        $NewObj = [PSCustomObject]@{
                                            BaseFileName = $BaseFileName
                                            STIGInfo     = $STIGInfo
                                            TargetData   = (Get-DeepCopy $TargetData)
                                            ScanArgs     = (Get-DeepCopy $ScanArgs)
                                        }
                                        $SubJobs.Add($NewObj)
                                    }
                                }
                            }
                        }
                        "MongoDB3" {
                            [System.Collections.ArrayList]$MongoInstances = @(Get-MongoDBInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("MongoInstance", $null)
                            $ScanArgs.ModuleArgs.Add("Instance", "")
                            $ScanArgs.ModuleArgs.Add("Database", "")

                            ForEach ($instance in $MongoInstances) {
                                $ScanArgs.ModuleArgs.MongoInstance = $instance
                                $ScanArgs.ModuleArgs.Instance = ($instance.BindIP + "-" + $instance.BindPort)
                                $ScanArgs.ModuleArgs.Database = $instance.Database

                                # Set output filename
                                $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -STIGVersion $STIGData.StigVersion

                                # Update TargetData
                                $TargetData.WebOrDatabase = $true
                                $TargetData.Site = $($instance.BindIP)
                                $TargetData.Instance = $($instance.Database)

                                # Build and add sub job
                                $NewObj = [PSCustomObject]@{
                                    BaseFileName = $BaseFileName
                                    STIGInfo     = $STIGInfo
                                    TargetData   = (Get-DeepCopy $TargetData)
                                    ScanArgs     = (Get-DeepCopy $ScanArgs)
                                }
                                $SubJobs.Add($NewObj)
                            }
                        }
                        "PgSQL9x" {
                            [System.Collections.ArrayList]$PgInstances = @(Get-PostgreSQLInstances)

                            # Add additional module arguments
                            $ScanArgs.ModuleArgs.Add("PGInstance", $null)
                            $ScanArgs.ModuleArgs.Add("Instance", "")
                            $ScanArgs.ModuleArgs.Add("Database", "")

                            ForEach ($instance in $PgInstances) {
                                If ($instance.PSQLAccess) {
                                    $ScanArgs.ModuleArgs.PGInstance = $instance
                                    $ScanArgs.ModuleArgs.Instance = ($instance.Server + "-" + $instance.Port)
                                    $ScanArgs.ModuleArgs.Database = $instance.Database

                                    # Set output filename
                                    $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -SiteOrInstance $ScanArgs.ModuleArgs.Instance -Database $ScanArgs.ModuleArgs.Database -STIGVersion $STIGData.StigVersion

                                    # Update TargetData
                                    $TargetData.WebOrDatabase = $true
                                    $TargetData.Site = $($instance.Server)
                                    $TargetData.Instance = $($instance.Database)

                                    # Build and add sub job
                                    $NewObj = [PSCustomObject]@{
                                        BaseFileName = $BaseFileName
                                        STIGInfo     = $STIGInfo
                                        TargetData   = (Get-DeepCopy $TargetData)
                                        ScanArgs     = (Get-DeepCopy $ScanArgs)
                                    }
                                    $SubJobs.Add($NewObj)
                                }
                                Else {
                                    Write-Log -Path $STIGLog -Message "----------------Skipping CKL------------------" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    Write-Log -Path $STIGLog -Message "ERROR: STIG: $($STIG.Name) PSQL access requirement not met." -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                    $HbaFile = Join-Path -Path "$($instance.PG_DATA)" -ChildPath "pg_hba.conf"
                                    Write-Log -Path $STIGLog -Message "ERROR: Local trust authentication method must be set in $($HbaFile)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                    Write-Log -Path $STIGLog -Message "ERROR: Skipping Server: $($instance.Server), Port: $($instance.Port), Database: $($instance.Database) " -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                }
                            }
                        }
                        Default {
                            # Set output filename
                            $BaseFileName = Format-BaseFileName -Hostname $TargetData.HostName -STIGShortName $STIGData.ShortName -STIGVersion $STIGData.StigVersion

                            # Build and add sub job
                            $NewObj = [PSCustomObject]@{
                                BaseFileName = $BaseFileName
                                STIGInfo     = $STIGInfo
                                TargetData   = (Get-DeepCopy $TargetData)
                                ScanArgs     = (Get-DeepCopy $ScanArgs)
                            }
                            $SubJobs.Add($NewObj)
                        }
                    }

                    # Add scan job
                    $NewObj = [PSCustomObject]@{
                        STIGData = $STIGData
                        SubJobs  = $SubJobs
                    }
                    $ScanJobs.Add($NewObj)

                    # Remove module after adding job to queue.  Will be imported for scan when needed.
                    Remove-Module $Item.PsModule -Force
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "Unable to process $($Item.ShortName) - skipping" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    $($_.InvocationInfo.ScriptName)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    Line: $($_.InvocationInfo.ScriptLineNumber)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Log -Path $STIGLog -Message "    $(($_.InvocationInfo.Line).Trim())" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    Write-Host "Unable to process $($Item.ShortName) - skipping" -ForegroundColor Red
                    Write-Host $_.Exception.Message -ForegroundColor Red
                }
            }

            # Execute the scans
            $FailedCheck = $false
            ForEach ($Job in $ScanJobs) {
                Try {
                    Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Evaluating STIG: $($Job.STIGData.Name)" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                    Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $CurrentMainStep++

                    Write-Log -Path $STIGLog -Message "Invoking scan" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    $ModError = ""
                    Try {

                        Write-Log -Path $STIGLog -Message "Importing scan module: $($Job.STIGData.PsModule)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        If ($PowerShellVersion -lt [Version]"7.0") {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -ErrorAction Stop
                        }
                        Else {
                            Import-Module (Join-Path -Path $PsScriptRoot -ChildPath "Modules" | Join-Path -ChildPath $($Job.STIGData.PsModule)) -SkipEditionCheck -ErrorAction Stop
                        }
                        $PsModule = (Get-Module $Job.STIGData.PsModule)
                        Write-Log -Path $STIGLog -Message "Module Version: $($PsModule.Version)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    }
                    Catch {
                        $ModError = $_.Exception.Message
                    }

                    If ($ModError) {
                        # If module failed to import, display reason and continue to next STIG.
                        Write-Log -Path $STIGLog -Message "ERROR: $($ModError)" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    }
                    Else {
                        # Build ESData Object
                        $ESData = [Ordered]@{
                            ESVersion     = $ESVersion
                            StartTime     = (Get-Date -Format 'o')
                            ModuleName    = $PsModule.Name
                            ModuleVersion = $PsModule.Version
                            STIGName      = $Job.STIGData.Name
                            STIGShortName = $Job.STIGData.ShortName
                            CanCombine    = $Job.STIGData.CanCombine
                            STIGXMLName   = $($Job.STIGData.StigXmlPath | Split-Path -Leaf)
                            BaseFileName  = ""
                            AnswerFile    = $($Job.SubJobs.ScanArgs.ModuleArgs.AnswerFile -replace "'", "")
                            FileName      = ""
                        }

                        # Set filename and additional requirements
                        ForEach ($SubJob in $Job.SubJobs) {
                            # Update BaseFileName if -SelectVuln is used
                            If ($SelectVuln) {
                                $SubJob.BaseFileName = "Partial_$($SubJob.BaseFileName)"
                            }

                            $ESData.BaseFileName = $($SubJob.BaseFileName)

                            # Write Site/Intance info to log
                            If ($SubJob.TargetData.Site) {
                                Write-Log -Path $STIGLog -Message "Site: $($SubJob.TargetData.Site)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }
                            If ($SubJob.TargetData.Instance) {
                                Write-Log -Path $STIGLog -Message "Instance: $($SubJob.TargetData.Instance)" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                            }

                            # Execute scan
                            $ScanArgs = $SubJob.ScanArgs
                            $VulnResults = Invoke-STIGScan @ScanArgs

                            # Look for any failed checks
                            If ($VulnResults | Where-Object CheckError -EQ $true) {
                                $FailedCheck = $true
                            }

                            # Build ScanObject
                            $ScanObject = [System.Collections.Generic.List[System.Object]]::new()
                            $NewObj = [PSCustomObject]@{
                                ESData      = $ESData
                                STIGInfo    = $SubJob.STIGInfo
                                TargetData  = $SubJob.TargetData
                                VulnResults = $VulnResults
                            }
                            $ScanObject.Add($NewObj)

                            # Send ScanObject to outputs (CKL, CKLB, CSV, XCCDF)
                            If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)")) {
                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..."
                                $tmpChecklistPath = Join-Path -Path $tmpResultsPath -ChildPath "Checklist"
                                If (-Not(Test-Path $tmpChecklistPath)) {
                                    $null = New-Item -Path $tmpChecklistPath -ItemType Directory
                                }
                                $GenerateSingleCKL = $false
                                $GenerateSingleCKLB = $false
                                $GenerateSingleCSV = $false
                                If ("CKL" -in $Output) {
                                    $GenerateSingleCKL = $true
                                }
                                If ("CombinedCKL" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKL = $true
                                    }
                                }
                                If ("CKLB" -in $Output) {
                                    $GenerateSingleCKLB = $true
                                }
                                If ("CombinedCKLB" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCKLB = $true
                                    }
                                }
                                If ("CSV" -in $Output) {
                                    $GenerateSingleCSV = $true
                                }
                                If ("CombinedCSV" -in $Output) {
                                    If ($ScanObject.ESData.CanCombine -ne $true) {
                                        $GenerateSingleCSV = $true
                                    }
                                }
                                If ("XCCDF" -in $Output) {
                                    $GenerateSingleXCCDF = $true
                                }

                                If ($GenerateSingleCKL) {
                                    Write-Log -Path $STIGLog -Message "Creating CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                                    $ChecklistValid = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                    }
                                }

                                If ($GenerateSingleCKLB) {
                                    Write-Log -Path $STIGLog -Message "Creating CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                                    $ChecklistValid = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObject -OutputPath $SaveFile -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent

                                    # Action for validation result
                                    If ($ChecklistValid) {
                                        $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                    }
                                }

                                if ($GenerateSingleCSV) {
                                    Write-Log -Path $STIGLog -Message "Creating CSV file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                                    if ($ParamList) {
                                        Format-Object -ScanObject $ScanObject -OutputPayload $OutputPayload -ParamList $ParamList | Export-Csv -NoTypeInformation -Path $SaveFile
                                    }
                                    else {
                                        Format-Object -ScanObject $ScanObject -OutputPayload $OutputPayload | Export-Csv -NoTypeInformation -Path $SaveFile
                                    }

                                    $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                }

                                If ($GenerateSingleXCCDF) {
                                    Write-Log -Path $STIGLog -Message "Creating XCCDF file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                    $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($ESData.BaseFileName)_$(Get-Date -Format yyyyMMdd-HHmmss).xccdf.xml")
                                    $XCCDF = Format-XCCDF -ScanObject $ScanObject -OutputPath $SaveFile -Marking $Marking -ESPath $PSScriptRoot

                                    # Action for validation result
                                    If ($XCCDF -eq $true) {
                                        $ScanObject.ESData.FileName = $(Split-Path $SaveFile -Leaf)
                                    }
                                    Else {
                                        $XCCDF | Get-ErrorInformation
                                        ForEach ($Item in ($ErrorData.PSObject.Properties).Name) {
                                            Write-Log -Path $STIGLog -Message "$($Item) : $($ErrorData.$Item)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                                        }
                                    }
                                }

                                Write-Progress -Id ($ProgressId + 1) -ParentId $ProgressId -Activity "Generating checklists..." -Completed
                            }
                            # Add to ScanObjects object console or combined checklist output
                            $ScanObjects.Add($ScanObject)
                        }

                        Write-Log -Path $STIGLog -Message "Removing scan module from memory" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Remove-Module $Job.STIGData.PsModule -Force
                        [System.GC]::Collect()
                    }
                }
                Catch {
                    $ErrorData = $_ | Get-ErrorInformation
                    If ($STIGLog -and (Test-Path $STIGLog)) {
                        ForEach ($Item in ($ErrorData.PSObject.Properties).Name) {
                            Write-Log -Path $STIGLog -Message "$($Item) : $($ErrorData.$Item)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    Write-Log -Path $STIGLog -Message "Continuing Processing" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                    [System.GC]::Collect()
                }
            }

            # Create combined checklists
            If (($Output -split ",").Trim() -match @("(^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)")) {
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating combined checklists" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                If (($Output -split ",").Trim() -match @("(^CombinedCKL$)")) {
                    Write-Log -Path $STIGLog -Message "Creating combined CKL file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).ckl")
                    }
                    $null = Format-CKL -SchemaPath $Checklist_xsd -ScanObject $ScanObjects -OutputPath $SaveFile -Marking $Marking -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
                If (($Output -split ",").Trim() -match @("(^CombinedCKLB$)")) {
                    Write-Log -Path $STIGLog -Message "Creating combined CKLB file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).cklb")
                    }
                    $null = Format-CKLB -SchemaPath $Checklist_json -ScanObject $ScanObjects -OutputPath $SaveFile -WorkingDir $WorkingDir -ESPath $PSScriptRoot -OSPlatform $OSPlatform -LogComponent $LogComponent
                }
                If (($Output -split ",").Trim() -match @("(^CombinedCSV$)")) {
                    Write-Log -Path $STIGLog -Message "Creating combined CSV file" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                    # Set combined checklist filename
                    If ($SelectVuln) {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "Partial_$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                    }
                    Else {
                        $SaveFile = $(Join-Path -Path $tmpChecklistPath -ChildPath "$($MachineName)_COMBINED_$(Get-Date -Format yyyyMMdd-HHmmss).csv")
                    }
                    if ($ParamList) {
                        Format-Object -ScanObject $ScanObjects -OutputPayload $OutputPayload -ParamList $ParamList | Export-Csv -NoTypeInformation -Path $SaveFile
                    }
                    else {
                        Format-Object -ScanObject $ScanObjects -OutputPayload $OutputPayload | Export-Csv -NoTypeInformation -Path $SaveFile
                    }
                }
            }

            If ($FailedCheck -eq $true) {
                Write-Log -Path $STIGLog -Message "Please report issues to https://spork.navsea.navy.mil/nswc-crane-division/evaluate-stig/-/issues" -WriteOutToStream -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
            }

            # Send results to STIG Manager
            If (($Output -split ",").Trim() -match @("(^STIGManager$)")) {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Importing to STIG Manager" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++

                Try {
                    if ($SMPassphrase) {
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -SMPassphrase $SMPassphrase -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }
                    else {
                        $SMImport_Params = Get-SMParameters -SMCollection $SMCollection -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog
                    }

                    Import-Asset @SMImport_Params
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            # Send results to Splunk
            If (($Output -split ",").Trim() -match @("(^Splunk$)")) {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Importing to Splunk" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                Try {
                    $Splunk_Params = Get-SplunkParameters -SplunkHECName $SplunkHECName -OutputPayload $OutputPayload -ScanObject $ScanObjects -ScriptRoot $PsScriptRoot -WorkingDir $WorkingDir -OSPlatform $OSPlatform -LogComponent $LogComponent -Logpath $STIGLog

                    Import-Event @Splunk_Params
                }
                Catch {
                    Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }

            # Create OQE
            If (($Output -split ",").Trim() -match @("(^OQE$)")) {
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Switch ($OSPlatform) {
                    "Windows" {
                        Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating Objective Quality Evidence (OQE) output" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                        $CurrentMainStep++
                        Write-Log -Path $STIGLog -Message "Generating Objective Quality Evidence (OQE) output" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        Try {
                            $tmpOQEPath = $(Join-Path -Path $tmpResultsPath -ChildPath "OQE")
                            If (-Not(Test-Path $tmpOQEPath)) {
                                $null = New-Item -Path $tmpOQEPath -ItemType Directory
                            }

                            # Group Policy Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Pulling Group Policy Report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $GPResultFile = "GPResult_$(${env:computername})_$($Date).html"
                                If ($UserToProcess -and $UserToProcess.SID -notin @("NA", ".DEFAULT")) {
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/USER $($UserToProcess.Username) /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                                Else {
                                    Write-Log -Path $STIGLog -Message "    No profile selected as user to evaluate.  Group Policy results will not include user policies." -Component $LogComponent -Type "Warning" -OSPlatform $OSPlatform
                                    Start-Process -FilePath GPResult.exe -ArgumentList "/SCOPE COMPUTER /H $tmpOQEPath\$($GPResultFile)" -Wait -WindowStyle Hidden
                                }
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # AppLocker Report
                            Try {
                                Write-Log -Path $STIGLog -Message "Collecting AppLocker effective policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                $AppLockerPolFile = "AppLockerPol_$(${env:computername})_$($Date).xml"
                                If (($PsVersionTable.PSVersion -join ".") -lt [Version]"7.0") {
                                    Import-Module AppLocker
                                }
                                Else {
                                    Import-Module AppLocker -SkipEditionCheck
                                }
                                Get-AppLockerPolicy -Effective -Xml -ErrorAction Stop | Out-File $tmpOQEPath\$($AppLockerPolFile) -Force -Encoding UTF8
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }

                            # Security Policy
                            Try {
                                $SecPolFile = "SecPol_$(${env:computername})_$($Date).ini"
                                Write-Log -Path $STIGLog -Message "Exporting security policy" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                                Start-Process -FilePath secedit.exe -ArgumentList "/export /cfg $($tmpOQEPath)\$($SecPolFile)" -Wait -WindowStyle Hidden
                            }
                            Catch {
                                Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                            }
                        }
                        Catch {
                            Write-Log -Path $STIGLog -Message "ERROR: $($_.Exception.Message)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                        }
                    }
                    "Linux" {
                        $CurrentMainStep++
                        # Placeholder in the event there is something we want to provide as OQE for Linux systems.
                    }
                }
            }

            Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform

            If (($Output -split ",").Trim() -match @("(^Summary$)")) {
                # Create summary report
                Write-Log -Path $STIGLog -Message "Generating summary report" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Generating summary report" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
                $CurrentMainStep++
                if ($Marking) {
                    Write-SummaryReport -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -OSPlatform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType -Marking $Marking
                }
                else {
                    Write-SummaryReport -ScanResult $ScanObjects -OutputPath $tmpResultsPath -ProcessedUser $UserToProcess.Username -Detail -OSPlatform $OSPlatform -ScanStartDate $ScanStartDate -ScanType $ScanType
                }

                # Create Summary HTML
                $SummaryFile = Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.xml
                [xml]$TempSR = New-Object xml

                $null = $TempSR.AppendChild($TempSR.CreateElement('Summaries'))
                $summary = New-Object xml
                $Summary.Load($SummaryFile)
                $ImportedSummary = $TempSR.ImportNode($Summary.DocumentElement, $true)
                $null = $TempSR.DocumentElement.AppendChild($ImportedSummary)

                $TempSR.Summaries.Summary.Results.Result | ForEach-Object {
                    #Build STIG name
                    $STIGName = [String]"$($_.STIG -replace '_', ' ') V$($_.Version)R$($_.Release)"
                    If ($_.Site) {
                        $STIGName = $STIGName + " ($($_.Site))"
                    }
                    If ($_.Instance) {
                        $STIGName = $STIGName + " ($($_.Instance))"
                    }
                    $_.SetAttribute("STIG", $STIGName)
                    $_.SetAttribute("StartTime", [String]($_.StartTime -replace "\.\d+", ""))
                    $CurrentScoreNode = $_.AppendChild($TempSR.CreateElement('CurrentScore'))
                    $CurrentScore = ([int]$_.CAT_I.NotAFinding + [int]$_.CAT_II.NotAFinding + [int]$_.CAT_III.NotAFinding + [int]$_.CAT_I.Not_Applicable + [int]$_.CAT_II.Not_Applicable + [int]$_.CAT_III.Not_Applicable) / ([int]$_.CAT_I.Total + [int]$_.CAT_II.Total + [int]$_.CAT_III.Total)
                    $CurrentScoreNode.SetAttribute("Score", $CurrentScore)
                }
                $TempSR.Save($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml))

                $SummaryReportXLST = New-Object System.XML.Xsl.XslCompiledTransform
                $SummaryReportXLST.Load($(Join-Path -Path $PsScriptRoot -ChildPath "xml" | Join-Path -ChildPath SummaryReport.xslt))
                $SummaryReportXLST.Transform($(Join-Path -Path $WorkingDir -ChildPath TempSR.xml), $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html))

                if ($Marking) {
                    #Add Marking Header and Footer
                    $SRHTML = $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html)
                    (Get-Content $SRHTML) -replace "<body>", "<body>`n    <header align=`"center`">$Marking</header>" | Set-Content $SRHTML

                    Add-Content $(Join-Path -Path $tmpResultsPath -ChildPath SummaryReport.html) "<footer align=`"center`">$Marking</footer>"
                }
            }

            # Manage previous results and move results to ResultsPath
            If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                If ($SelectSTIG) {
                    $PreviousArgs = @{SelectedShortName = $STIGsToProcess.ShortName}
                    If (($Output -split ",").Trim() -match @("(^CombinedCKL$)")) {
                        $PreviousArgs.Add("SelectedCombinedCKL", $true)
                    }
                    If (($Output -split ",").Trim() -match @("(^CombinedCKLB$)")) {
                        $PreviousArgs.Add("SelectedCombinedCKLB", $true)
                    }
                    If (($Output -split ",").Trim() -match @("(^CombinedCSV$)")) {
                        $PreviousArgs.Add("SelectedCombinedCSV", $true)
                    }
                    If (($Output -split ",").Trim() -match @("(^Summary$)")) {
                        $PreviousArgs.Add("SelectedSummary", $true)
                    }
                    If (($Output -split ",").Trim() -match @("(^OQE$)")) {
                        $PreviousArgs.Add("SelectedOQE", $true)
                    }
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep @PreviousArgs -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }
                Else {
                    Initialize-PreviousProcessing -ResultsPath $ResultsPath -PreviousToKeep $PreviousToKeep -LogPath $STIGLog -LogComponent $LogComponent -OSPlatform $OSPlatform
                }

                # Move results to ResultsPath
                Write-Log -Path $STIGLog -Message "-" -TemplateMessage LineBreak-Dash -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Log -Path $STIGLog -Message "Copying output files to $ResultsPath" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Get-ChildItem $tmpResultsPath -Recurse | ForEach-Object {
                    If ($_.PSIsContainer) {
                        If (-Not(Test-Path $(Join-Path $ResultsPath -ChildPath $_.Name))) {
                            $null = New-Item -Path $(Join-Path $ResultsPath -ChildPath $_.Name) -ItemType Directory
                        }
                    }
                    Else {
                        Copy-Item -Path $_.FullName -Destination $(Join-Path -Path $ResultsPath -ChildPath $(($_.DirectoryName) -ireplace [regex]::Escape($tmpResultsPath), ""))
                    }
                }
            }

            # Apply tattoo
            If ($ApplyTattoo) {
                Write-Log -Path $STIGLog -Message "Applying Evaluate-STIG tattoo" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Switch ($OSPlatform) {
                    "Windows" {
                        # Mark registry with EvaluateStigVersion.  This can be used for SCCM detection method.
                        $RegistryPath = "HKLM:\SOFTWARE\Evaluate-STIG"
                        If (-Not(Test-Path -Path $RegistryPath)) {
                            $null = New-Item -Path $RegistryPath -Force
                        }
                        Write-Log -Path $STIGLog -Message "Creating 'Version' value under HKLM:\SOFTWARE\Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $null = New-ItemProperty -Path $RegistryPath -Name Version -Value $ESVersion -PropertyType String -Force

                        Write-Log -Path $STIGLog -Message "Creating 'LastRun' value under HKLM:\SOFTWARE\Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        $null = New-ItemProperty -Path $RegistryPath -Name LastRun -Value $(Get-Date -Format FileDateTime) -PropertyType String -Force
                    }
                    "Linux" {
                        Write-Log -Path $STIGLog -Message "Creating 'Version' value in /etc/Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        "Version: $ESVersion" | Out-File /etc/Evaluate-STIG

                        Write-Log -Path $STIGLog -Message "Creating 'LastRun' value in /etc/Evaluate-STIG" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                        "LastRun: $(Get-Date -Format FileDateTime)" | Out-File /etc/Evaluate-STIG -Append
                    }
                }
            }

            # Clean up
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent

            # Finalize log and get totals
            $TimeToComplete = New-TimeSpan -Start $StartTime -End (Get-Date)
            $FormatedTime = "{0:c}" -f $TimeToComplete
            Write-Log -Path $STIGLog -Message "Done!" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "Total Time : $($FormatedTime)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$)")) {
                $TotalChecklists = (Get-ChildItem -Path "$ResultsPath\Checklist" | Where-Object {($_.Extension -In @(".ckl", ".cklb", ".csv") -or $_.Name -like "*.xccdf.xml")}  | Measure-Object).Count
                Write-Log -Path $STIGLog -Message "Total checklists in Results Directory : $($TotalChecklists)" -WriteOutToStream -FGColor Green -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
                Write-Host ""
                Write-Host "Results saved to " -ForegroundColor Green -NoNewline; Write-Host "$($ResultsPath)" -ForegroundColor Cyan
            }
            Write-Log -Path $STIGLog -Message "Exiting with exit code $ExitCode" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            If ($Marking) {
                Write-Log -Path $STIGLog -Message "                                                                                          $Marking                                                                                          " -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            }
            Write-Host ""

            # Copy Evaluate-STIG.log to results path
            If (($Output -split ",").Trim() -match @("(^CKL$|^CKLB$|^CSV$|^XCCDF$|^CombinedCKL$|^CombinedCKLB$|^CombinedCSV$|^Summary$|^OQE$)")) {
                Copy-Item $STIGLog -Destination $ResultsPath -Force -ErrorAction Stop
            }

            # Complete progress bar
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "Finalizing and cleaning up" -Completed

            If (($Output -split ",").Trim() -match @("(^Console$)")) {
                # Build ScanResult
                $ScanResult = @{}
                $ScanResult.Add($MachineName, $ScanObjects)
            }
        }

        # Remove InstalledSoftware variable if it exists
        If ($null -ne $Global:InstalledSoftware) {
            Remove-Variable -Name InstalledSoftware -Scope Global
        }

        If (($Output -split ",").Trim() -match @("(^Console$)")) {
            If (($ScanResult.Keys | Measure-Object).Count -ge 1) {
                # Configure a default display set
                $defaultDisplaySet = 'STIGInfo', 'TargetData', 'VulnResults'

                # Create the default property display set
                $defaultDisplayPropertySet = New-Object System.Management.Automation.PSPropertySet('DefaultDisplayPropertySet', [string[]]$defaultDisplaySet)
                $PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]@($defaultDisplayPropertySet)

                # Format, sort, and return output
                $ScanOutput = [ordered]@{}
                If ($ComputerName) {
                    ForEach ($HostName in ($ScanResult.Keys | Sort-Object)) {
                        $STIGOutput = [ordered]@{}
                        ForEach ($Target in ($ScanResult.$HostName.Keys | Sort-Object)) {
                            $OutObject = $ScanResult.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                            $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                            $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                            $STIGOutput.Add($($Target), $OutObject)
                        }
                        $ScanOutput.Add($HostName, $STIGOutput)
                    }
                }
                Else {
                    $tmpOutput = @{}
                    ForEach ($Target in $ScanResult.Keys | Sort-Object) {
                        $STIGOutput = [ordered]@{}

                        $STIGCount = @{}
                        # Handle if STIG has more than a count of 1
                        $ScanResult[$Target].ESData.STIGShortName | Sort-Object -Unique | ForEach-Object {
                            $STIGCount | Add-Member -MemberType NoteProperty -Name $_ -Value 1
                        }
                        If (($ScanResult.$Target.ESData.STIGShortName | Measure-Object).Count -gt 1) {
                            $GroupedObj = $ScanResult.$Target.ESData.STIGShortName.GetEnumerator() | Group-Object
                        }
                        Else {
                            $GroupedObj = $ScanResult.$Target.ESData.STIGShortName | Group-Object
                        }

                        Foreach ($Object in $ScanResult[$Target]) {
                            $OutObject = $Object | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                            $OutObject.PSObject.TypeNames.Insert(0, 'ScanResult')
                            $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers

                            $STIGShortName = $Object.ESData.STIGShortName
                            if (($GroupedObj | Where-Object {$_.Name -like $STIGShortName}).Count -gt 1) {
                                $STIGCount[$STIGShortName]++
                                $STIGOutput.Add("$STIGShortName$($STIGCount[$STIGShortName])", $OutObject)
                            }
                            Else {
                                $STIGOutput.Add($($STIGShortName), $OutObject)
                            }
                        }
                        $tmpOutput.Add($Target, $STIGOutput)
                    }

                    # Put into new object to ensure sorting
                    $HostNames = $tmpOutput.GetEnumerator().Name
                    ForEach ($HostName in $HostNames) {
                        $OrderedResults = [ordered]@{}
                        ($tmpOutput.$($HostName).GetEnumerator() | Sort-Object Name) | ForEach-Object {
                            $OrderedResults.Add($($_.Name), $($tmpOutput.$($HostName).$($_.Name)))
                        }
                        $ScanOutput.Add($HostName, $OrderedResults)
                    }
                }

                if ($JSON) {
                    $STIGOutput = [System.Collections.Generic.List[System.Object]]::new()
                    ForEach ($HostName in ($ScanOutput.Keys | Sort-Object)) {
                        ForEach ($Target in ($ScanOutput.$HostName.Keys | Sort-Object)) {
                            $OutObject = $ScanOutput.$HostName.$Target | Select-Object STIGInfo, TargetData, VulnResults, ESdata
                            $OutObject.PSObject.TypeNames.Insert(0, 'ScanOutput')
                            $OutObject | Add-Member MemberSet PSStandardMembers $PSStandardMembers
                            $STIGOutput.Add($OutObject)
                        }
                    }
                    if ($ParamList) {
                        $JSONResult = Format-Object -ScanObject $STIGOutput -OutputPayload $OutputPayload -ParamList $ParamList | ConvertTo-Json
                    }
                    else {
                        $JSONResult = Format-Object -ScanObject $STIGOutput -OutputPayload $OutputPayload | ConvertTo-Json
                    }
                }
            }

            If ($PSStyleBackup) {
                # Restore $PSStyle settings
                $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
            }

            # Remove Evaluate-STIG modules from memory
            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()

            If ($JSONResult) {
                Return $JSONResult
            }
            ElseIf ($ScanOutput) {
                Return $ScanOutput
            }
        }
        Else {
            If ($PSStyleBackup) {
                # Restore $PSStyle settings
                $PSStyle.Progress.View = $PSStyleBackup.ProgressView
                $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
            }

            Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
            [System.GC]::Collect()

            Exit $ExitCode
        }
    }
    Catch {
        If ($ExitCode -eq 0) {
            $ExitCode = 1
        }

        $MasterFunctionsLoaded = $false
        If (Get-Module -Name Master_Functions) {
            $MasterFunctionsLoaded = $true
        }

        # Get Error Data
        If ($MasterFunctionsLoaded) {
            $ErrorData = $_ | Get-ErrorInformation
            If ($STIGLog -and (Test-Path $STIGLog)) {
                ForEach ($Item in ($ErrorData.PSObject.Properties).Name) {
                    Write-Log -Path $STIGLog -Message "$($Item) : $($ErrorData.$Item)" -Component $LogComponent -Type "Error" -OSPlatform $OSPlatform
                }
            }
        }
        Else {
            $ErrorData = [PSCustomObject]@{
                ExceptionMessage = $_.Exception.Message
            }
        }

        # --- Begin : Clean up ---
        # Update progress bar
        If ($ProgressId) {
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "ERROR DETECTED : Cleaning up" -PercentComplete ($CurrentMainStep / $TotalMainSteps * 100)
        }

        # Initiate post scan cleanup
        If ($WorkingDir -and (Test-Path $WorkingDir) -and $MasterFunctionsLoaded) {
            Invoke-ScanCleanup -WorkingDir $WorkingDir -Logpath $STIGLog -OSPlatform $OSPlatform -LogComponent $LogComponent
        }

        # Remove $InstalledSoftware variable from memory
        If ($null -ne $Global:InstalledSoftware) {
            Remove-Variable -Name InstalledSoftware -Scope Global
        }

        # Remove $AvailableModules variable from memory
        If ($null -ne $AvailableModules) {
            Remove-Variable -Name 'AvailableModules'
        }

        # Remove remote scan lock file from disk
        If ($ComputerName) {
            If (Test-Path $RemoteWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $RemoteWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Remove Cisco lock file from disk
        If ($CiscoConfig) {
            If (Test-Path $CiscoWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $CiscoWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Remove VCenter lock file from disk
        If ($VCenterApplianceName -or $VMName) {
            If (Test-Path $VCenterWorkingDir\Evaluate-STIG.lck) {
                Remove-Item -Path $VCenterWorkingDir\Evaluate-STIG.lck -Force -ErrorAction SilentlyContinue
            }
        }

        # Write final log entry
        If ($STIGLog -and (Test-Path $STIGLog) -and $MasterFunctionsLoaded) {
            Write-Log -Path $STIGLog -Message "Exiting with exit code $ExitCode" -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
            Write-Log -Path $STIGLog -Message "End Local Logging" -TemplateMessage LineBreak-Text -Component $LogComponent -Type "Info" -OSPlatform $OSPlatform
        }

        # Remove Evaluate-STIG modules from memory
        Get-Module | Where-Object Path -Like "$($PsScriptRoot)*" | Remove-Module -Force
        [System.GC]::Collect()

        # Complete progress bar
        If ($ProgressId) {
            Write-Progress -Id $ProgressId -Activity $ProgressActivity -Status "ERROR DETECTED : Cleaning up" -Completed
        }


        If ($PSStyleBackup) {
            # Restore $PSStyle settings
            $PSStyle.Progress.View = $PSStyleBackup.ProgressView
            $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::$($PSStyleBackup.OutputRendering)
        }
        # --- Begin : Clean up ---

        # Write the error to console and exit with $ExitCode
        $MaxLength = (($ErrorData | Get-Member | Where-Object MemberType -In @('Property', 'NoteProperty')).Name | Measure-Object -Maximum -Property Length).Maximum + 1
        ForEach ($Item in (($ErrorData | Get-Member | Where-Object MemberType -In @('Property', 'NoteProperty')) | Where-Object Name -EQ 'ExceptionMessage').Name) {
            $WhiteSpace = " " * ($MaxLength - $Item.Length)
            Write-Host "$($Item)$($WhiteSpace): $($ErrorData.$Item)" -ForegroundColor Red -BackgroundColor Black
        }

        Exit $ExitCode
    }
}

# SIG # Begin signature block
# MIIL+QYJKoZIhvcNAQcCoIIL6jCCC+YCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCCpnGw1cCuKzoXA
# YT3exW4n5s7FoaQNNQCqfM3C5/CvkqCCCTswggR6MIIDYqADAgECAgQDAgTXMA0G
# CSqGSIb3DQEBCwUAMFoxCzAJBgNVBAYTAlVTMRgwFgYDVQQKEw9VLlMuIEdvdmVy
# bm1lbnQxDDAKBgNVBAsTA0RvRDEMMAoGA1UECxMDUEtJMRUwEwYDVQQDEwxET0Qg
# SUQgQ0EtNTkwHhcNMjAwNzE1MDAwMDAwWhcNMjUwNDAyMTMzODMyWjBpMQswCQYD
# VQQGEwJVUzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0Qx
# DDAKBgNVBAsTA1BLSTEMMAoGA1UECxMDVVNOMRYwFAYDVQQDEw1DUy5OU1dDQ0Qu
# MDAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2/Z91ObHZ009DjsX
# ySa9T6DbT+wWgX4NLeTYZwx264hfFgUnIww8C9Mm6ht4mVfo/qyvmMAqFdeyhXiV
# PZuhbDnzdKeXpy5J+oxtWjAgnWwJ983s3RVewtV063W7kYIqzj+Ncfsx4Q4TSgmy
# ASOMTUhlzm0SqP76zU3URRj6N//NzxAcOPLlfzxcFPMpWHC9zNlVtFqGtyZi/STj
# B7ed3BOXmddiLNLCL3oJm6rOsidZstKxEs3I1llWjsnltn7fR2/+Fm+roWrF8B4z
# ekQOu9t8WRZfNohKoXVtVuwyUAJQF/8kVtIa2YyxTUAF9co9qVNZgko/nx0gIdxS
# hxmEvQIDAQABo4IBNzCCATMwHwYDVR0jBBgwFoAUdQmmFROuhzz6c5QA8vD1ebmy
# chQwQQYDVR0fBDowODA2oDSgMoYwaHR0cDovL2NybC5kaXNhLm1pbC9jcmwvRE9E
# SURDQV81OV9OQ09ERVNJR04uY3JsMA4GA1UdDwEB/wQEAwIHgDAWBgNVHSAEDzAN
# MAsGCWCGSAFlAgELKjAdBgNVHQ4EFgQUVusXc6nN92xmQ3XNN+/76hosJFEwZQYI
# KwYBBQUHAQEEWTBXMDMGCCsGAQUFBzAChidodHRwOi8vY3JsLmRpc2EubWlsL3Np
# Z24vRE9ESURDQV81OS5jZXIwIAYIKwYBBQUHMAGGFGh0dHA6Ly9vY3NwLmRpc2Eu
# bWlsMB8GA1UdJQQYMBYGCisGAQQBgjcKAw0GCCsGAQUFBwMDMA0GCSqGSIb3DQEB
# CwUAA4IBAQBCSdogBcOfKqyGbKG45lLicG1LJ2dmt0Hwl7QkKrZNNEDh2Q2+uzB7
# SRmADtSOVjVf/0+1B4jBoyty90WL52rMPVttb8tfm0f/Wgw6niz5WQZ+XjFRTFQa
# M7pBNU54vI3bH4MFBTXUOEoSr0FELFQaByUWfWKrGLnEqYtpDde5FZEYKRv6td6N
# ZH7m5JOiCfEK6gun3luq7ckvx5zIXjr5VKhp+S0Aai3ZR/eqbBZ0wcUF3DOYlqVs
# LiPT0jWompwkfSnxa3fjNHD+FKvd/7EMQM/wY0vZyIObto3QYrLru6COAyY9cC/s
# Dj+R4K4392w1LWdo3KrNzkCFMAX6j/bWMIIEuTCCA6GgAwIBAgICAwUwDQYJKoZI
# hvcNAQELBQAwWzELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJubWVu
# dDEMMAoGA1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFjAUBgNVBAMTDURvRCBSb290
# IENBIDMwHhcNMTkwNDAyMTMzODMyWhcNMjUwNDAyMTMzODMyWjBaMQswCQYDVQQG
# EwJVUzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0QxDDAK
# BgNVBAsTA1BLSTEVMBMGA1UEAxMMRE9EIElEIENBLTU5MIIBIjANBgkqhkiG9w0B
# AQEFAAOCAQ8AMIIBCgKCAQEAzBeEny3BCletEU01Vz8kRy8cD2OWvbtwMTyunFaS
# hu+kIk6g5VRsnvbhK3Ho61MBmlGJc1pLSONGBhpbpyr2l2eONAzmi8c8917V7Bpn
# JZvYj66qGRmY4FXX6UZQ6GdALKKedJKrMQfU8LmcBJ/LGcJ0F4635QocGs9UoFS5
# hLgVyflDTC/6x8EPbi/JXk6N6iod5JIAxNp6qW/5ZBvhiuMo19oYX5LuUy9B6W7c
# A0cRygvYcwKKYK+cIdBoxAj34yw2HJI8RQt490QPGClZhz0WYFuNSnUJgTHsdh2V
# NEn2AEe2zYhPFNlCu3gSmOSp5vxpZWbMIQ8cTv4pRWG47wIDAQABo4IBhjCCAYIw
# HwYDVR0jBBgwFoAUbIqUonexgHIdgXoWqvLczmbuRcAwHQYDVR0OBBYEFHUJphUT
# roc8+nOUAPLw9Xm5snIUMA4GA1UdDwEB/wQEAwIBhjBnBgNVHSAEYDBeMAsGCWCG
# SAFlAgELJDALBglghkgBZQIBCycwCwYJYIZIAWUCAQsqMAsGCWCGSAFlAgELOzAM
# BgpghkgBZQMCAQMNMAwGCmCGSAFlAwIBAxEwDAYKYIZIAWUDAgEDJzASBgNVHRMB
# Af8ECDAGAQH/AgEAMAwGA1UdJAQFMAOAAQAwNwYDVR0fBDAwLjAsoCqgKIYmaHR0
# cDovL2NybC5kaXNhLm1pbC9jcmwvRE9EUk9PVENBMy5jcmwwbAYIKwYBBQUHAQEE
# YDBeMDoGCCsGAQUFBzAChi5odHRwOi8vY3JsLmRpc2EubWlsL2lzc3VlZHRvL0RP
# RFJPT1RDQTNfSVQucDdjMCAGCCsGAQUFBzABhhRodHRwOi8vb2NzcC5kaXNhLm1p
# bDANBgkqhkiG9w0BAQsFAAOCAQEAOQUb0g6nPvWoc1cJ5gkhxSyGA3bQKu8HnKbg
# +vvMpMFEwo2p30RdYHGvA/3GGtrlhxBqAcOqeYF5TcXZ4+Fa9CbKE/AgloCuTjEY
# t2/0iaSvdw7y9Vqk7jyT9H1lFIAQHHN3TEwN1nr7HEWVkkg41GXFxU01UHfR7vgq
# TTz+3zZL2iCqADVDspna0W5pF6yMla6gn4u0TmWu2SeqBpctvdcfSFXkzQBZGT1a
# D/W2Fv00KwoQgB2l2eiVk56mEjN/MeI5Kp4n57mpREsHutP4XnLQ01ZN2qgn+844
# JRrzPQ0pazPYiSl4PeI2FUItErA6Ob/DPF0ba2y3k4dFkUTApzGCAhQwggIQAgEB
# MGIwWjELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292ZXJubWVudDEMMAoG
# A1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxFTATBgNVBAMTDERPRCBJRCBDQS01OQIE
# AwIE1zANBglghkgBZQMEAgEFAKCBhDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAA
# MBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgor
# BgEEAYI3AgEVMC8GCSqGSIb3DQEJBDEiBCA3Kpo+WPBihM/yneAFmLAR8M48o3Zf
# F9Tt8kJoWJUSuTANBgkqhkiG9w0BAQEFAASCAQB2Hghe/zFECR1Wsl7F0KqZA/1I
# bhUH+JE/w45/J+bkFcPuFuJa108oNOzQummg7abA0H3E/liTJeQrLG65EGoxD5wI
# sgxdhCaVXE7NMpiP2ul4gzovdpOBeXOB4wDIEu1zMNu8FazhL8YdbzSMXBZr42lX
# 96wWCH3DKuaEb829u4dg1OGSamaz2hcgf5menHz8MQXnFaQJm8aTqSAUVlpYQbuO
# XXCRLoPdawBNgYyjMDTKHTUeMdpFhH5lcPsL2wjnv4CBQUufsHdJTDBQjaYI5ZgM
# YewAnBr4b9Vxe/xIfUD2A+xBE2I30u2RR/Rod0LKWlUrCwOZHvZpBqW1YvrA
# SIG # End signature block
